package sintaticalAnalyzes;


import java.io.*;
import java_cup.runtime.*;
import java.util.*;
import GOType.GoArrayType;
import GOType.GoConstants;
import GOType.GoElement;
import GOType.GoElementList;
import GOType.GoExpr;
import GOType.GoForStmt;
import GOType.GoFunc_call;
import GOType.GoIfStmt;
import GOType.GoIndex;
import GOType.GoLiteralValue;
import GOType.GoOperand;
import GOType.GoParameterDecl;
import GOType.GoPointerType;
import GOType.GoPrimaryExpr;
import GOType.GoSignature;
import GOType.GoType;
import GOType.GoTypeLit;
import GOType.GoTypeName;
import GOType.GoUnaryExpr;
import GOType.GoValue;
import Util.Env;
import Util.Register;
import Util.SimpleBlock;
import Util.SymbolTableEntry;
import Util.Tac;
import Util.TacLineInfo;

import java.io.File;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.FileNotFoundException;

@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\361\000\002\002\004\000\002\010\003\000\002\010" +
    "\003\000\002\010\005\000\002\011\003\000\002\011\003" +
    "\000\002\320\005\000\002\321\003\000\002\012\003\000" +
    "\002\012\003\000\002\012\003\000\002\014\006\000\002" +
    "\024\003\000\002\016\004\000\002\322\005\000\002\322" +
    "\006\000\002\017\004\000\002\031\004\000\002\031\004" +
    "\000\002\031\003\000\002\033\005\000\002\033\004\000" +
    "\002\034\004\000\002\204\005\000\002\204\002\000\002" +
    "\035\004\000\002\035\003\000\002\326\002\000\002\044" +
    "\006\000\002\042\003\000\002\211\005\000\002\211\002" +
    "\000\002\053\003\000\002\053\003\000\002\327\002\000" +
    "\002\054\006\000\002\226\003\000\002\226\003\000\002" +
    "\330\002\000\002\064\005\000\002\065\005\000\002\047" +
    "\003\000\002\047\003\000\002\050\004\000\002\212\005" +
    "\000\002\212\002\000\002\213\003\000\002\213\005\000" +
    "\002\056\006\000\002\030\004\000\002\216\005\000\002" +
    "\216\002\000\002\057\004\000\002\217\005\000\002\217" +
    "\002\000\002\052\004\000\002\222\005\000\002\222\002" +
    "\000\002\223\003\000\002\223\005\000\002\061\004\000" +
    "\002\224\004\000\002\224\002\000\002\225\004\000\002" +
    "\225\004\000\002\067\003\000\002\067\004\000\002\067" +
    "\003\000\002\067\005\000\002\072\003\000\002\072\003" +
    "\000\002\072\003\000\002\072\003\000\002\072\003\000" +
    "\002\331\002\000\002\100\006\000\002\230\003\000\002" +
    "\230\002\000\002\332\002\000\002\231\005\000\002\231" +
    "\002\000\002\101\004\000\002\233\005\000\002\233\002" +
    "\000\002\102\003\000\002\104\003\000\002\104\003\000" +
    "\002\107\003\000\002\107\004\000\002\112\005\000\002" +
    "\025\003\000\002\025\005\000\002\025\005\000\002\025" +
    "\005\000\002\025\005\000\002\025\005\000\002\025\005" +
    "\000\002\025\005\000\002\025\005\000\002\025\005\000" +
    "\002\025\005\000\002\025\005\000\002\025\005\000\002" +
    "\025\005\000\002\025\005\000\002\025\005\000\002\025" +
    "\005\000\002\025\005\000\002\025\005\000\002\117\003" +
    "\000\002\117\004\000\002\002\003\000\002\002\003\000" +
    "\002\002\003\000\002\002\003\000\002\002\003\000\002" +
    "\004\003\000\002\004\003\000\002\004\003\000\002\004" +
    "\003\000\002\004\003\000\002\004\003\000\002\005\003" +
    "\000\002\005\003\000\002\005\003\000\002\005\003\000" +
    "\002\006\003\000\002\006\003\000\002\006\003\000\002" +
    "\006\003\000\002\006\003\000\002\006\003\000\002\006" +
    "\003\000\002\003\003\000\002\003\003\000\002\003\003" +
    "\000\002\003\003\000\002\003\003\000\002\003\003\000" +
    "\002\043\003\000\002\043\003\000\002\043\003\000\002" +
    "\043\003\000\002\043\003\000\002\043\003\000\002\043" +
    "\003\000\002\043\003\000\002\043\003\000\002\043\003" +
    "\000\002\043\003\000\002\043\003\000\002\043\003\000" +
    "\002\122\004\000\002\122\002\000\002\317\005\000\002" +
    "\317\003\000\002\317\005\000\002\317\002\000\002\245" +
    "\003\000\002\245\003\000\002\007\004\000\002\246\003" +
    "\000\002\246\003\000\002\246\002\000\002\333\002\000" +
    "\002\136\010\000\002\334\002\000\002\137\012\000\002" +
    "\335\002\000\002\135\006\000\002\336\002\000\002\337" +
    "\002\000\002\135\011\000\002\135\003\000\002\340\002" +
    "\000\002\135\006\000\002\341\002\000\002\342\002\000" +
    "\002\135\011\000\002\135\003\000\002\131\003\000\002" +
    "\147\011\000\002\147\007\000\002\147\006\000\002\147" +
    "\010\000\002\254\004\000\002\254\002\000\002\151\006" +
    "\000\002\151\005\000\002\343\002\000\002\344\002\000" +
    "\002\134\011\000\002\134\006\000\002\266\003\000\002" +
    "\265\003\000\002\265\003\000\002\345\002\000\002\160" +
    "\007\000\002\324\004\000\002\271\003\000\002\271\002" +
    "\000\002\124\004\000\002\124\003\000\002\125\004\000" +
    "\002\125\003\000\002\145\004\000\002\120\004\000\002" +
    "\120\004\000\002\120\004\000\002\120\004\000\002\120" +
    "\004\000\002\120\004\000\002\120\004\000\002\120\004" +
    "\000\002\120\004\000\002\120\004\000\002\120\004\000" +
    "\002\120\004\000\002\346\002\000\002\121\006\000\002" +
    "\127\004\000\002\126\004\000\002\126\003\000\002\347" +
    "\002\000\002\350\002\000\002\170\010\000\002\302\003" +
    "\000\002\311\005\000\002\311\002\000\002\303\003\000" +
    "\002\312\005\000\002\312\002\000\002\171\004\000\002" +
    "\172\004\000\002\304\005\000\002\304\002\000\002\305" +
    "\003\000\002\305\005\000\002\173\004\000\002\173\004" +
    "\000\002\173\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u0161\000\004\027\uff22\001\002\000\004\027\010\001" +
    "\002\000\004\002\006\001\002\000\004\002\001\001\002" +
    "\000\004\101\012\001\002\000\004\004\011\001\002\000" +
    "\004\101\uff19\001\002\000\014\002\uff1d\014\uff1d\031\uff1d" +
    "\040\015\042\uff1d\001\002\000\004\101\u0162\001\002\000" +
    "\012\002\uff21\014\uff21\031\uff21\042\uff21\001\002\000\012" +
    "\004\023\011\017\070\024\104\020\001\002\000\012\002" +
    "\uff1f\014\uff1f\031\uff1f\042\uff1f\001\002\000\004\101\uff11" +
    "\001\002\000\004\011\032\001\002\000\004\101\uff18\001" +
    "\002\000\004\101\uff15\001\002\000\004\011\031\001\002" +
    "\000\012\004\uff16\011\uff16\071\uff16\104\uff16\001\002\000" +
    "\012\004\023\011\017\071\027\104\020\001\002\000\004" +
    "\101\030\001\002\000\004\101\uff14\001\002\000\012\004" +
    "\uff17\011\uff17\071\uff17\104\uff17\001\002\000\004\101\uff12" +
    "\001\002\000\004\101\uff13\001\002\000\012\002\uff1a\014" +
    "\041\031\034\042\044\001\002\000\006\004\047\070\u015a" +
    "\001\002\000\004\002\uff1c\001\002\000\004\002\uff20\001" +
    "\002\000\004\101\uffe0\001\002\000\004\101\uffd7\001\002" +
    "\000\004\004\265\001\002\000\004\101\263\001\002\000" +
    "\004\101\uffe1\001\002\000\006\004\047\070\052\001\002" +
    "\000\004\101\uffd8\001\002\000\016\004\074\014\077\057" +
    "\065\070\067\072\073\106\076\001\002\000\020\004\uffce" +
    "\014\uffce\057\uffce\070\uffce\072\uffce\100\057\106\uffce\001" +
    "\002\000\004\101\uffc7\001\002\000\004\101\uffca\001\002" +
    "\000\006\004\uffc8\071\uffc8\001\002\000\006\004\047\071" +
    "\055\001\002\000\004\101\056\001\002\000\004\101\uffc6" +
    "\001\002\000\006\004\uffc9\071\uffc9\001\002\000\004\004" +
    "\061\001\002\000\016\004\uffd0\014\uffd0\057\uffd0\070\uffd0" +
    "\072\uffd0\106\uffd0\001\002\000\020\004\uffce\014\uffce\057" +
    "\uffce\070\uffce\072\uffce\100\057\106\uffce\001\002\000\016" +
    "\004\uffcf\014\uffcf\057\uffcf\070\uffcf\072\uffcf\106\uffcf\001" +
    "\002\000\006\101\uffc3\106\261\001\002\000\102\043\ufffc" +
    "\044\ufffc\045\ufffc\046\ufffc\047\ufffc\050\ufffc\051\ufffc\052" +
    "\ufffc\053\ufffc\054\ufffc\055\ufffc\056\ufffc\057\ufffc\060\ufffc" +
    "\061\ufffc\062\ufffc\063\ufffc\064\ufffc\065\ufffc\070\ufffc\071" +
    "\ufffc\072\ufffc\073\ufffc\074\ufffc\075\ufffc\076\ufffc\100\ufffc" +
    "\101\ufffc\102\ufffc\104\256\105\ufffc\106\ufffc\001\002\000" +
    "\014\004\074\014\077\057\065\070\067\072\073\001\002" +
    "\000\100\043\ufffd\044\ufffd\045\ufffd\046\ufffd\047\ufffd\050" +
    "\ufffd\051\ufffd\052\ufffd\053\ufffd\054\ufffd\055\ufffd\056\ufffd" +
    "\057\ufffd\060\ufffd\061\ufffd\062\ufffd\063\ufffd\064\ufffd\065" +
    "\ufffd\070\ufffd\071\ufffd\072\ufffd\073\ufffd\074\ufffd\075\ufffd" +
    "\076\ufffd\100\ufffd\101\ufffd\102\ufffd\105\ufffd\106\ufffd\001" +
    "\002\000\014\004\074\014\077\057\065\070\067\072\073" +
    "\001\002\000\004\101\uffc5\001\002\000\014\071\ufff8\074" +
    "\ufff8\100\ufff8\101\ufff8\106\ufff8\001\002\000\014\071\000" +
    "\074\000\100\000\101\000\106\000\001\002\000\004\005" +
    "\251\001\002\000\102\043\ufffa\044\ufffa\045\ufffa\046\ufffa" +
    "\047\ufffa\050\ufffa\051\ufffa\052\ufffa\053\ufffa\054\ufffa\055" +
    "\ufffa\056\ufffa\057\ufffa\060\ufffa\061\ufffa\062\ufffa\063\ufffa" +
    "\064\ufffa\065\ufffa\070\ufffa\071\ufffa\072\ufffa\073\ufffa\074" +
    "\ufffa\075\ufffa\076\ufffa\100\ufffa\101\ufffa\102\ufffa\104\ufffa" +
    "\105\ufffa\106\ufffa\001\002\000\014\071\uffff\074\uffff\100" +
    "\uffff\101\uffff\106\uffff\001\002\000\036\004\074\005\150" +
    "\006\126\007\132\010\143\011\127\053\131\054\145\056" +
    "\146\057\137\064\141\066\130\070\136\072\073\001\002" +
    "\000\004\070\104\001\002\000\014\071\ufff9\074\ufff9\100" +
    "\ufff9\101\ufff9\106\ufff9\001\002\000\014\071\ufff7\074\ufff7" +
    "\100\ufff7\101\ufff7\106\ufff7\001\002\000\014\071\ufff1\074" +
    "\ufff1\100\ufff1\101\ufff1\106\ufff1\001\002\000\026\004\074" +
    "\014\077\057\065\070\121\071\uffee\072\073\074\uffee\100" +
    "\uffee\101\uffee\106\uffee\001\002\000\016\004\111\014\077" +
    "\057\065\070\067\071\112\072\073\001\002\000\006\071" +
    "\uffe7\100\uffe7\001\002\000\014\004\074\014\077\057\065" +
    "\070\067\072\073\001\002\000\004\071\116\001\002\000" +
    "\006\071\uffe9\100\uffe9\001\002\000\022\004\uffce\014\uffce" +
    "\057\uffce\070\uffce\071\ufffa\072\uffce\100\057\104\ufffa\001" +
    "\002\000\026\004\uffec\014\uffec\057\uffec\070\uffec\071\uffec" +
    "\072\uffec\074\uffec\100\uffec\101\uffec\106\uffec\001\002\000" +
    "\006\071\uffeb\100\114\001\002\000\014\004\111\014\077" +
    "\057\065\070\067\072\073\001\002\000\006\071\uffea\100" +
    "\uffea\001\002\000\026\004\uffed\014\uffed\057\uffed\070\uffed" +
    "\071\uffed\072\uffed\074\uffed\100\uffed\101\uffed\106\uffed\001" +
    "\002\000\006\071\uffe8\100\uffe8\001\002\000\014\071\uffef" +
    "\074\uffef\100\uffef\101\uffef\106\uffef\001\002\000\016\004" +
    "\111\014\077\057\065\070\067\071\112\072\073\001\002" +
    "\000\014\071\ufff0\074\ufff0\100\ufff0\101\ufff0\106\ufff0\001" +
    "\002\000\006\071\124\100\uffe7\001\002\000\014\071\ufffe" +
    "\074\ufffe\100\ufffe\101\ufffe\106\ufffe\001\002\000\074\043" +
    "\uffa7\044\uffa7\045\uffa7\046\uffa7\047\uffa7\050\uffa7\051\uffa7" +
    "\052\uffa7\053\uffa7\054\uffa7\055\uffa7\056\uffa7\057\uffa7\060" +
    "\uffa7\061\uffa7\062\uffa7\063\uffa7\064\uffa7\065\uffa7\071\uffa7" +
    "\073\uffa7\074\uffa7\075\uffa7\076\uffa7\100\uffa7\101\uffa7\102" +
    "\uffa7\105\uffa7\106\uffa7\001\002\000\076\043\uffba\044\uffba" +
    "\045\uffba\046\uffba\047\uffba\050\uffba\051\uffba\052\uffba\053" +
    "\uffba\054\uffba\055\uffba\056\uffba\057\uffba\060\uffba\061\uffba" +
    "\062\uffba\063\uffba\064\uffba\065\uffba\071\uffba\072\uffba\073" +
    "\uffba\074\uffba\075\uffba\076\uffba\100\uffba\101\uffba\102\uffba" +
    "\105\uffba\106\uffba\001\002\000\076\043\uffb8\044\uffb8\045" +
    "\uffb8\046\uffb8\047\uffb8\050\uffb8\051\uffb8\052\uffb8\053\uffb8" +
    "\054\uffb8\055\uffb8\056\uffb8\057\uffb8\060\uffb8\061\uffb8\062" +
    "\uffb8\063\uffb8\064\uffb8\065\uffb8\071\uffb8\072\uffb8\073\uffb8" +
    "\074\uffb8\075\uffb8\076\uffb8\100\uffb8\101\uffb8\102\uffb8\105" +
    "\uffb8\106\uffb8\001\002\000\036\004\uff7a\005\uff7a\006\uff7a" +
    "\007\uff7a\010\uff7a\011\uff7a\053\uff7a\054\uff7a\056\uff7a\057" +
    "\uff7a\064\uff7a\066\uff7a\070\uff7a\072\uff7a\001\002\000\036" +
    "\004\uff7c\005\uff7c\006\uff7c\007\uff7c\010\uff7c\011\uff7c\053" +
    "\uff7c\054\uff7c\056\uff7c\057\uff7c\064\uff7c\066\uff7c\070\uff7c" +
    "\072\uff7c\001\002\000\076\043\uffbb\044\uffbb\045\uffbb\046" +
    "\uffbb\047\uffbb\050\uffbb\051\uffbb\052\uffbb\053\uffbb\054\uffbb" +
    "\055\uffbb\056\uffbb\057\uffbb\060\uffbb\061\uffbb\062\uffbb\063" +
    "\uffbb\064\uffbb\065\uffbb\071\uffbb\072\uffbb\073\uffbb\074\uffbb" +
    "\075\uffbb\076\uffbb\100\uffbb\101\uffbb\102\uffbb\105\uffbb\106" +
    "\uffbb\001\002\000\076\043\uffaa\044\uffaa\045\uffaa\046\uffaa" +
    "\047\uffaa\050\uffaa\051\uffaa\052\uffaa\053\uffaa\054\uffaa\055" +
    "\uffaa\056\uffaa\057\uffaa\060\uffaa\061\uffaa\062\uffaa\063\uffaa" +
    "\064\uffaa\065\uffaa\071\uffaa\072\uffaa\073\uffaa\074\uffaa\075" +
    "\uffaa\076\uffaa\100\uffaa\101\uffaa\102\uffaa\105\uffaa\106\uffaa" +
    "\001\002\000\076\043\uffbe\044\uffbe\045\uffbe\046\uffbe\047" +
    "\uffbe\050\uffbe\051\uffbe\052\uffbe\053\uffbe\054\uffbe\055\uffbe" +
    "\056\uffbe\057\uffbe\060\uffbe\061\uffbe\062\uffbe\063\uffbe\064" +
    "\uffbe\065\uffbe\071\uffbe\072\uffbe\073\uffbe\074\uffbe\075\uffbe" +
    "\076\uffbe\100\uffbe\101\uffbe\102\uffbe\105\uffbe\106\uffbe\001" +
    "\002\000\076\043\uff94\044\uff94\045\uff94\046\uff94\047\uff94" +
    "\050\uff94\051\uff94\052\uff94\053\uff94\054\uff94\055\uff94\056" +
    "\uff94\057\uff94\060\uff94\061\uff94\062\uff94\063\uff94\064\uff94" +
    "\065\uff94\071\uff94\072\244\073\uff94\074\uff94\075\uff94\076" +
    "\uff94\100\uff94\101\uff94\102\uff94\105\uff94\106\uff94\001\002" +
    "\000\036\004\074\005\150\006\126\007\132\010\143\011" +
    "\127\053\131\054\145\056\146\057\137\064\141\066\130" +
    "\070\136\072\073\001\002\000\036\004\uff78\005\uff78\006" +
    "\uff78\007\uff78\010\uff78\011\uff78\053\uff78\054\uff78\056\uff78" +
    "\057\uff78\064\uff78\066\uff78\070\uff78\072\uff78\001\002\000" +
    "\076\043\uffc0\044\uffc0\045\uffc0\046\uffc0\047\uffc0\050\uffc0" +
    "\051\uffc0\052\uffc0\053\uffc0\054\uffc0\055\uffc0\056\uffc0\057" +
    "\uffc0\060\uffc0\061\uffc0\062\uffc0\063\uffc0\064\uffc0\065\uffc0" +
    "\071\uffc0\072\uffc0\073\uffc0\074\uffc0\075\uffc0\076\uffc0\100" +
    "\uffc0\101\uffc0\102\uffc0\105\uffc0\106\uffc0\001\002\000\036" +
    "\004\uff77\005\uff77\006\uff77\007\uff77\010\uff77\011\uff77\053" +
    "\uff77\054\uff77\056\uff77\057\uff77\064\uff77\066\uff77\070\uff77" +
    "\072\uff77\001\002\000\004\074\222\001\002\000\076\043" +
    "\uffb9\044\uffb9\045\uffb9\046\uffb9\047\uffb9\050\uffb9\051\uffb9" +
    "\052\uffb9\053\uffb9\054\uffb9\055\uffb9\056\uffb9\057\uffb9\060" +
    "\uffb9\061\uffb9\062\uffb9\063\uffb9\064\uffb9\065\uffb9\071\uffb9" +
    "\072\uffb9\073\uffb9\074\uffb9\075\uffb9\076\uffb9\100\uffb9\101" +
    "\uffb9\102\uffb9\105\uffb9\106\uffb9\001\002\000\004\101\uffc1" +
    "\001\002\000\036\004\uff7b\005\uff7b\006\uff7b\007\uff7b\010" +
    "\uff7b\011\uff7b\053\uff7b\054\uff7b\056\uff7b\057\uff7b\064\uff7b" +
    "\066\uff7b\070\uff7b\072\uff7b\001\002\000\036\004\uff79\005" +
    "\uff79\006\uff79\007\uff79\010\uff79\011\uff79\053\uff79\054\uff79" +
    "\056\uff79\057\uff79\064\uff79\066\uff79\070\uff79\072\uff79\001" +
    "\002\000\060\043\160\044\163\045\171\046\167\047\172" +
    "\050\155\051\165\052\153\053\156\054\173\055\170\056" +
    "\174\057\164\060\161\061\166\062\162\063\175\065\157" +
    "\071\uffcb\074\uffcb\100\uffcb\101\uffcb\105\uffcb\001\002\000" +
    "\076\043\uffbc\044\uffbc\045\uffbc\046\uffbc\047\uffbc\050\uffbc" +
    "\051\uffbc\052\uffbc\053\uffbc\054\uffbc\055\uffbc\056\uffbc\057" +
    "\uffbc\060\uffbc\061\uffbc\062\uffbc\063\uffbc\064\uffbc\065\uffbc" +
    "\071\uffbc\072\uffbc\073\uffbc\074\uffbc\075\uffbc\076\uffbc\100" +
    "\uffbc\101\uffbc\102\uffbc\105\uffbc\106\uffbc\001\002\000\036" +
    "\004\074\005\150\006\126\007\132\010\143\011\127\053" +
    "\131\054\145\056\146\057\137\064\141\066\130\070\136" +
    "\072\073\001\002\000\074\043\uff93\044\uff93\045\uff93\046" +
    "\uff93\047\uff93\050\uff93\051\uff93\052\uff93\053\uff93\054\uff93" +
    "\055\uff93\056\uff93\057\uff93\060\uff93\061\uff93\062\uff93\063" +
    "\uff93\064\uff93\065\uff93\071\uff93\073\uff93\074\uff93\075\uff93" +
    "\076\uff93\100\uff93\101\uff93\102\uff93\105\uff93\106\uff93\001" +
    "\002\000\036\004\074\005\150\006\126\007\132\010\143" +
    "\011\127\053\131\054\145\056\146\057\137\064\141\066" +
    "\130\070\136\072\073\001\002\000\014\071\uffcd\074\uffcd" +
    "\100\217\101\uffcd\105\uffcd\001\002\000\036\004\074\005" +
    "\150\006\126\007\132\010\143\011\127\053\131\054\145" +
    "\056\146\057\137\064\141\066\130\070\136\072\073\001" +
    "\002\000\036\004\074\005\150\006\126\007\132\010\143" +
    "\011\127\053\131\054\145\056\146\057\137\064\141\066" +
    "\130\070\136\072\073\001\002\000\036\004\074\005\150" +
    "\006\126\007\132\010\143\011\127\053\131\054\145\056" +
    "\146\057\137\064\141\066\130\070\136\072\073\001\002" +
    "\000\036\004\074\005\150\006\126\007\132\010\143\011" +
    "\127\053\131\054\145\056\146\057\137\064\141\066\130" +
    "\070\136\072\073\001\002\000\036\004\074\005\150\006" +
    "\126\007\132\010\143\011\127\053\131\054\145\056\146" +
    "\057\137\064\141\066\130\070\136\072\073\001\002\000" +
    "\036\004\074\005\150\006\126\007\132\010\143\011\127" +
    "\053\131\054\145\056\146\057\137\064\141\066\130\070" +
    "\136\072\073\001\002\000\036\004\074\005\150\006\126" +
    "\007\132\010\143\011\127\053\131\054\145\056\146\057" +
    "\137\064\141\066\130\070\136\072\073\001\002\000\036" +
    "\004\074\005\150\006\126\007\132\010\143\011\127\053" +
    "\131\054\145\056\146\057\137\064\141\066\130\070\136" +
    "\072\073\001\002\000\036\004\074\005\150\006\126\007" +
    "\132\010\143\011\127\053\131\054\145\056\146\057\137" +
    "\064\141\066\130\070\136\072\073\001\002\000\036\004" +
    "\074\005\150\006\126\007\132\010\143\011\127\053\131" +
    "\054\145\056\146\057\137\064\141\066\130\070\136\072" +
    "\073\001\002\000\036\004\074\005\150\006\126\007\132" +
    "\010\143\011\127\053\131\054\145\056\146\057\137\064" +
    "\141\066\130\070\136\072\073\001\002\000\036\004\074" +
    "\005\150\006\126\007\132\010\143\011\127\053\131\054" +
    "\145\056\146\057\137\064\141\066\130\070\136\072\073" +
    "\001\002\000\036\004\074\005\150\006\126\007\132\010" +
    "\143\011\127\053\131\054\145\056\146\057\137\064\141" +
    "\066\130\070\136\072\073\001\002\000\036\004\074\005" +
    "\150\006\126\007\132\010\143\011\127\053\131\054\145" +
    "\056\146\057\137\064\141\066\130\070\136\072\073\001" +
    "\002\000\036\004\074\005\150\006\126\007\132\010\143" +
    "\011\127\053\131\054\145\056\146\057\137\064\141\066" +
    "\130\070\136\072\073\001\002\000\036\004\074\005\150" +
    "\006\126\007\132\010\143\011\127\053\131\054\145\056" +
    "\146\057\137\064\141\066\130\070\136\072\073\001\002" +
    "\000\036\004\074\005\150\006\126\007\132\010\143\011" +
    "\127\053\131\054\145\056\146\057\137\064\141\066\130" +
    "\070\136\072\073\001\002\000\074\043\uff96\044\uff96\045" +
    "\uff96\046\uff96\047\uff96\050\uff96\051\uff96\052\uff96\053\uff96" +
    "\054\uff96\055\uff96\056\uff96\057\uff96\060\uff96\061\uff96\062" +
    "\uff96\063\uff96\064\uff96\065\uff96\071\uff96\073\uff96\074\uff96" +
    "\075\uff96\076\uff96\100\uff96\101\uff96\102\uff96\105\uff96\106" +
    "\uff96\001\002\000\074\043\uffa1\044\uffa1\045\uffa1\046\uffa1" +
    "\047\uffa1\050\uffa1\051\uffa1\052\uffa1\053\uffa1\054\uffa1\055" +
    "\uffa1\056\uffa1\057\164\060\161\061\166\062\162\063\175" +
    "\064\uffa1\065\157\071\uffa1\073\uffa1\074\uffa1\075\uffa1\076" +
    "\uffa1\100\uffa1\101\uffa1\102\uffa1\105\uffa1\106\uffa1\001\002" +
    "\000\074\043\uffa3\044\uffa3\045\uffa3\046\uffa3\047\uffa3\050" +
    "\uffa3\051\uffa3\052\uffa3\053\uffa3\054\uffa3\055\uffa3\056\uffa3" +
    "\057\164\060\161\061\166\062\162\063\175\064\uffa3\065" +
    "\157\071\uffa3\073\uffa3\074\uffa3\075\uffa3\076\uffa3\100\uffa3" +
    "\101\uffa3\102\uffa3\105\uffa3\106\uffa3\001\002\000\074\043" +
    "\uff9b\044\uff9b\045\uff9b\046\uff9b\047\uff9b\050\uff9b\051\uff9b" +
    "\052\uff9b\053\156\054\173\055\170\056\174\057\164\060" +
    "\161\061\166\062\162\063\175\064\uff9b\065\157\071\uff9b" +
    "\073\uff9b\074\uff9b\075\uff9b\076\uff9b\100\uff9b\101\uff9b\102" +
    "\uff9b\105\uff9b\106\uff9b\001\002\000\074\043\uffa0\044\uffa0" +
    "\045\uffa0\046\uffa0\047\uffa0\050\uffa0\051\uffa0\052\uffa0\053" +
    "\156\054\173\055\170\056\174\057\164\060\161\061\166" +
    "\062\162\063\175\064\uffa0\065\157\071\uffa0\073\uffa0\074" +
    "\uffa0\075\uffa0\076\uffa0\100\uffa0\101\uffa0\102\uffa0\105\uffa0" +
    "\106\uffa0\001\002\000\074\043\uffa2\044\uffa2\045\uffa2\046" +
    "\uffa2\047\uffa2\050\uffa2\051\uffa2\052\uffa2\053\uffa2\054\uffa2" +
    "\055\uffa2\056\uffa2\057\164\060\161\061\166\062\162\063" +
    "\175\064\uffa2\065\157\071\uffa2\073\uffa2\074\uffa2\075\uffa2" +
    "\076\uffa2\100\uffa2\101\uffa2\102\uffa2\105\uffa2\106\uffa2\001" +
    "\002\000\074\043\uff9f\044\uff9f\045\uff9f\046\uff9f\047\uff9f" +
    "\050\uff9f\051\uff9f\052\uff9f\053\156\054\173\055\170\056" +
    "\174\057\164\060\161\061\166\062\162\063\175\064\uff9f" +
    "\065\157\071\uff9f\073\uff9f\074\uff9f\075\uff9f\076\uff9f\100" +
    "\uff9f\101\uff9f\102\uff9f\105\uff9f\106\uff9f\001\002\000\074" +
    "\043\uff98\044\uff98\045\uff98\046\uff98\047\uff98\050\uff98\051" +
    "\uff98\052\uff98\053\uff98\054\uff98\055\uff98\056\uff98\057\uff98" +
    "\060\uff98\061\uff98\062\uff98\063\uff98\064\uff98\065\uff98\071" +
    "\uff98\073\uff98\074\uff98\075\uff98\076\uff98\100\uff98\101\uff98" +
    "\102\uff98\105\uff98\106\uff98\001\002\000\074\043\uff9d\044" +
    "\uff9d\045\uff9d\046\uff9d\047\uff9d\050\uff9d\051\uff9d\052\uff9d" +
    "\053\156\054\173\055\170\056\174\057\164\060\161\061" +
    "\166\062\162\063\175\064\uff9d\065\157\071\uff9d\073\uff9d" +
    "\074\uff9d\075\uff9d\076\uff9d\100\uff9d\101\uff9d\102\uff9d\105" +
    "\uff9d\106\uff9d\001\002\000\074\043\uff9a\044\uff9a\045\uff9a" +
    "\046\uff9a\047\uff9a\050\uff9a\051\uff9a\052\uff9a\053\uff9a\054" +
    "\uff9a\055\uff9a\056\uff9a\057\uff9a\060\uff9a\061\uff9a\062\uff9a" +
    "\063\uff9a\064\uff9a\065\uff9a\071\uff9a\073\uff9a\074\uff9a\075" +
    "\uff9a\076\uff9a\100\uff9a\101\uff9a\102\uff9a\105\uff9a\106\uff9a" +
    "\001\002\000\074\043\uffa5\044\uffa5\045\171\046\167\047" +
    "\172\050\155\051\165\052\153\053\156\054\173\055\170" +
    "\056\174\057\164\060\161\061\166\062\162\063\175\064" +
    "\uffa5\065\157\071\uffa5\073\uffa5\074\uffa5\075\uffa5\076\uffa5" +
    "\100\uffa5\101\uffa5\102\uffa5\105\uffa5\106\uffa5\001\002\000" +
    "\074\043\uff97\044\uff97\045\uff97\046\uff97\047\uff97\050\uff97" +
    "\051\uff97\052\uff97\053\uff97\054\uff97\055\uff97\056\uff97\057" +
    "\uff97\060\uff97\061\uff97\062\uff97\063\uff97\064\uff97\065\uff97" +
    "\071\uff97\073\uff97\074\uff97\075\uff97\076\uff97\100\uff97\101" +
    "\uff97\102\uff97\105\uff97\106\uff97\001\002\000\074\043\uff99" +
    "\044\uff99\045\uff99\046\uff99\047\uff99\050\uff99\051\uff99\052" +
    "\uff99\053\uff99\054\uff99\055\uff99\056\uff99\057\uff99\060\uff99" +
    "\061\uff99\062\uff99\063\uff99\064\uff99\065\uff99\071\uff99\073" +
    "\uff99\074\uff99\075\uff99\076\uff99\100\uff99\101\uff99\102\uff99" +
    "\105\uff99\106\uff99\001\002\000\074\043\uffa6\044\163\045" +
    "\171\046\167\047\172\050\155\051\165\052\153\053\156" +
    "\054\173\055\170\056\174\057\164\060\161\061\166\062" +
    "\162\063\175\064\uffa6\065\157\071\uffa6\073\uffa6\074\uffa6" +
    "\075\uffa6\076\uffa6\100\uffa6\101\uffa6\102\uffa6\105\uffa6\106" +
    "\uffa6\001\002\000\074\043\uff95\044\uff95\045\uff95\046\uff95" +
    "\047\uff95\050\uff95\051\uff95\052\uff95\053\uff95\054\uff95\055" +
    "\uff95\056\uff95\057\uff95\060\uff95\061\uff95\062\uff95\063\uff95" +
    "\064\uff95\065\uff95\071\uff95\073\uff95\074\uff95\075\uff95\076" +
    "\uff95\100\uff95\101\uff95\102\uff95\105\uff95\106\uff95\001\002" +
    "\000\074\043\uffa4\044\uffa4\045\uffa4\046\uffa4\047\uffa4\050" +
    "\uffa4\051\uffa4\052\uffa4\053\uffa4\054\uffa4\055\uffa4\056\uffa4" +
    "\057\164\060\161\061\166\062\162\063\175\064\uffa4\065" +
    "\157\071\uffa4\073\uffa4\074\uffa4\075\uffa4\076\uffa4\100\uffa4" +
    "\101\uffa4\102\uffa4\105\uffa4\106\uffa4\001\002\000\074\043" +
    "\uff9c\044\uff9c\045\uff9c\046\uff9c\047\uff9c\050\uff9c\051\uff9c" +
    "\052\uff9c\053\156\054\173\055\170\056\174\057\164\060" +
    "\161\061\166\062\162\063\175\064\uff9c\065\157\071\uff9c" +
    "\073\uff9c\074\uff9c\075\uff9c\076\uff9c\100\uff9c\101\uff9c\102" +
    "\uff9c\105\uff9c\106\uff9c\001\002\000\036\004\074\005\150" +
    "\006\126\007\132\010\143\011\127\053\131\054\145\056" +
    "\146\057\137\064\141\066\130\070\136\072\073\001\002" +
    "\000\064\043\160\044\163\045\171\046\167\047\172\050" +
    "\155\051\165\052\153\053\156\054\173\055\170\056\174" +
    "\057\164\060\161\061\166\062\162\063\175\064\uffcc\065" +
    "\157\071\uffcc\074\uffcc\100\uffcc\101\uffcc\105\uffcc\106\uffcc" +
    "\001\002\000\074\043\uff9e\044\uff9e\045\uff9e\046\uff9e\047" +
    "\uff9e\050\uff9e\051\uff9e\052\uff9e\053\156\054\173\055\170" +
    "\056\174\057\164\060\161\061\166\062\162\063\175\064" +
    "\uff9e\065\157\071\uff9e\073\uff9e\074\uff9e\075\uff9e\076\uff9e" +
    "\100\uff9e\101\uff9e\102\uff9e\105\uff9e\106\uff9e\001\002\000" +
    "\042\004\074\005\150\006\126\007\132\010\143\011\127" +
    "\053\131\054\145\056\146\057\137\064\141\066\130\070" +
    "\136\072\073\074\222\075\uffb1\001\002\000\076\043\uffbf" +
    "\044\uffbf\045\uffbf\046\uffbf\047\uffbf\050\uffbf\051\uffbf\052" +
    "\uffbf\053\uffbf\054\uffbf\055\uffbf\056\uffbf\057\uffbf\060\uffbf" +
    "\061\uffbf\062\uffbf\063\uffbf\064\uffbf\065\uffbf\071\uffbf\072" +
    "\uffbf\073\uffbf\074\uffbf\075\uffbf\076\uffbf\100\uffbf\101\uffbf" +
    "\102\uffbf\105\uffbf\106\uffbf\001\002\000\006\075\uffae\100" +
    "\uffae\001\002\000\006\075\uffab\100\uffab\001\002\000\006" +
    "\075\uffb3\100\uffb3\001\002\000\006\075\uffad\100\uffad\001" +
    "\002\000\052\043\160\044\163\045\171\046\167\047\172" +
    "\050\155\051\165\052\153\053\156\054\173\055\170\056" +
    "\174\057\164\060\161\061\166\062\162\063\175\065\157" +
    "\075\uffac\100\uffac\001\002\000\004\075\uffb7\001\002\000" +
    "\004\075\233\001\002\000\076\043\uffb6\044\uffb6\045\uffb6" +
    "\046\uffb6\047\uffb6\050\uffb6\051\uffb6\052\uffb6\053\uffb6\054" +
    "\uffb6\055\uffb6\056\uffb6\057\uffb6\060\uffb6\061\uffb6\062\uffb6" +
    "\063\uffb6\064\uffb6\065\uffb6\071\uffb6\072\uffb6\073\uffb6\074" +
    "\uffb6\075\uffb6\076\uffb6\100\uffb6\101\uffb6\102\uffb6\105\uffb6" +
    "\106\uffb6\001\002\000\006\075\uffb4\100\235\001\002\000" +
    "\004\075\uffb5\001\002\000\004\075\uffb2\001\002\000\006" +
    "\075\uffb0\100\240\001\002\000\040\004\074\005\150\006" +
    "\126\007\132\010\143\011\127\053\131\054\145\056\146" +
    "\057\137\064\141\066\130\070\136\072\073\074\222\001" +
    "\002\000\006\075\uffaf\100\uffaf\001\002\000\050\043\160" +
    "\044\163\045\171\046\167\047\172\050\155\051\165\052" +
    "\153\053\156\054\173\055\170\056\174\057\164\060\161" +
    "\061\166\062\162\063\175\065\157\071\243\001\002\000" +
    "\076\043\uffbd\044\uffbd\045\uffbd\046\uffbd\047\uffbd\050\uffbd" +
    "\051\uffbd\052\uffbd\053\uffbd\054\uffbd\055\uffbd\056\uffbd\057" +
    "\uffbd\060\uffbd\061\uffbd\062\uffbd\063\uffbd\064\uffbd\065\uffbd" +
    "\071\uffbd\072\uffbd\073\uffbd\074\uffbd\075\uffbd\076\uffbd\100" +
    "\uffbd\101\uffbd\102\uffbd\105\uffbd\106\uffbd\001\002\000\036" +
    "\004\074\005\150\006\126\007\132\010\143\011\127\053" +
    "\131\054\145\056\146\057\137\064\141\066\130\070\136" +
    "\072\073\001\002\000\076\043\uffa9\044\uffa9\045\uffa9\046" +
    "\uffa9\047\uffa9\050\uffa9\051\uffa9\052\uffa9\053\uffa9\054\uffa9" +
    "\055\uffa9\056\uffa9\057\uffa9\060\uffa9\061\uffa9\062\uffa9\063" +
    "\uffa9\064\uffa9\065\uffa9\071\uffa9\072\uffa9\073\uffa9\074\uffa9" +
    "\075\uffa9\076\uffa9\100\uffa9\101\uffa9\102\uffa9\105\uffa9\106" +
    "\uffa9\001\002\000\050\043\160\044\163\045\171\046\167" +
    "\047\172\050\155\051\165\052\153\053\156\054\173\055" +
    "\170\056\174\057\164\060\161\061\166\062\162\063\175" +
    "\065\157\073\247\001\002\000\076\043\uffa8\044\uffa8\045" +
    "\uffa8\046\uffa8\047\uffa8\050\uffa8\051\uffa8\052\uffa8\053\uffa8" +
    "\054\uffa8\055\uffa8\056\uffa8\057\uffa8\060\uffa8\061\uffa8\062" +
    "\uffa8\063\uffa8\064\uffa8\065\uffa8\071\uffa8\072\uffa8\073\uffa8" +
    "\074\uffa8\075\uffa8\076\uffa8\100\uffa8\101\uffa8\102\uffa8\105" +
    "\uffa8\106\uffa8\001\002\000\004\073\252\001\002\000\004" +
    "\073\ufff5\001\002\000\014\004\074\014\077\057\065\070" +
    "\067\072\073\001\002\000\014\071\ufff6\074\ufff6\100\ufff6" +
    "\101\ufff6\106\ufff6\001\002\000\004\071\124\001\002\000" +
    "\014\071\ufff4\074\ufff4\100\ufff4\101\ufff4\106\ufff4\001\002" +
    "\000\004\004\257\001\002\000\100\043\ufffb\044\ufffb\045" +
    "\ufffb\046\ufffb\047\ufffb\050\ufffb\051\ufffb\052\ufffb\053\ufffb" +
    "\054\ufffb\055\ufffb\056\ufffb\057\ufffb\060\ufffb\061\ufffb\062" +
    "\ufffb\063\ufffb\064\ufffb\065\ufffb\070\ufffb\071\ufffb\072\ufffb" +
    "\073\ufffb\074\ufffb\075\ufffb\076\ufffb\100\ufffb\101\ufffb\102" +
    "\ufffb\105\ufffb\106\ufffb\001\002\000\004\101\uffc2\001\002" +
    "\000\036\004\074\005\150\006\126\007\132\010\143\011" +
    "\127\053\131\054\145\056\146\057\137\064\141\066\130" +
    "\070\136\072\073\001\002\000\004\101\uffc4\001\002\000" +
    "\012\002\uff1a\014\041\031\034\042\044\001\002\000\004" +
    "\002\uff1b\001\002\000\004\070\uffdf\001\002\000\004\070" +
    "\104\001\002\000\004\101\uffdd\001\002\000\006\074\uffdb" +
    "\101\uffdc\001\002\000\004\101\uffde\001\002\000\004\074" +
    "\273\001\002\000\066\004\uffe2\005\uffe2\006\uffe2\007\uffe2" +
    "\010\uffe2\011\uffe2\012\uffe2\026\uffe2\030\uffe2\031\uffe2\033" +
    "\uffe2\036\uffe2\037\uffe2\041\uffe2\042\uffe2\053\uffe2\054\uffe2" +
    "\056\uffe2\057\uffe2\064\uffe2\066\uffe2\070\uffe2\072\uffe2\074" +
    "\uffe2\075\uffe2\101\uffe2\001\002\000\004\101\uffda\001\002" +
    "\000\072\004\305\005\150\006\126\007\132\010\143\011" +
    "\127\012\320\013\uffe4\017\uffe4\026\321\030\302\031\034" +
    "\033\312\036\327\037\324\041\315\042\044\053\131\054" +
    "\145\056\146\057\137\064\141\066\130\070\136\072\073" +
    "\074\313\075\uffe4\101\uff68\001\002\000\004\075\277\001" +
    "\002\000\004\101\uffd9\001\002\000\004\101\uff73\001\002" +
    "\000\004\101\uff6a\001\002\000\042\004\074\005\150\006" +
    "\126\007\132\010\143\011\127\053\131\054\145\056\146" +
    "\057\137\064\141\066\130\070\136\072\073\074\u013f\101" +
    "\uff68\001\002\000\004\101\uff70\001\002\000\070\043\uffbe" +
    "\044\uffbe\045\uffbe\046\uffbe\047\uffbe\050\uffbe\051\uffbe\052" +
    "\uffbe\053\uffbe\054\uffbe\055\uffbe\056\uffbe\057\uffbe\060\uffbe" +
    "\061\uffbe\062\uffbe\063\uffbe\064\uffbe\065\uffbe\070\u013b\072" +
    "\uffbe\074\uffbe\076\uffbe\100\uffbe\101\uffbe\102\uffbe\106\uffbe" +
    "\001\002\000\072\043\ufffa\044\ufffa\045\ufffa\046\ufffa\047" +
    "\ufffa\050\ufffa\051\ufffa\052\ufffa\053\ufffa\054\ufffa\055\ufffa" +
    "\056\ufffa\057\ufffa\060\ufffa\061\ufffa\062\ufffa\063\ufffa\064" +
    "\ufffa\065\ufffa\070\ufffa\072\ufffa\076\ufffa\100\ufffa\101\ufffa" +
    "\102\ufffa\104\ufffa\105\u0138\106\ufffa\001\002\000\004\101" +
    "\uff74\001\002\000\006\025\u0130\101\uff4e\001\002\000\004" +
    "\074\u012d\001\002\000\004\101\uff4d\001\002\000\040\004" +
    "\074\005\150\006\126\007\132\010\143\011\127\053\131" +
    "\054\145\056\146\057\137\064\141\066\130\070\136\072" +
    "\073\101\uff68\001\002\000\066\004\uffe6\005\uffe6\006\uffe6" +
    "\007\uffe6\010\uffe6\011\uffe6\012\uffe6\026\uffe6\030\uffe6\031" +
    "\uffe6\033\uffe6\036\uffe6\037\uffe6\041\uffe6\042\uffe6\053\uffe6" +
    "\054\uffe6\056\uffe6\057\uffe6\064\uffe6\066\uffe6\070\uffe6\072" +
    "\uffe6\074\uffe6\075\uffe6\101\uffe6\001\002\000\006\025\u0116" +
    "\101\uff54\001\002\000\040\004\074\005\150\006\126\007" +
    "\132\010\143\011\127\053\131\054\145\056\146\057\137" +
    "\064\141\066\130\070\136\072\073\101\uff37\001\002\000" +
    "\062\004\305\005\150\006\126\007\132\010\143\011\127" +
    "\012\320\026\321\030\302\031\034\033\312\036\327\041" +
    "\315\042\044\053\131\054\145\056\146\057\137\064\141" +
    "\066\130\070\136\072\073\074\313\101\uff68\001\002\000" +
    "\004\101\uff6d\001\002\000\006\004\u0108\101\uff35\001\002" +
    "\000\004\004\u0107\001\002\000\004\101\uff6b\001\002\000" +
    "\004\101\uff75\001\002\000\042\004\uff44\005\uff44\006\uff44" +
    "\007\uff44\010\uff44\011\uff44\053\uff44\054\uff44\056\uff44\057" +
    "\uff44\064\uff44\066\uff44\070\uff44\072\uff44\074\uff40\101\uff44" +
    "\001\002\000\004\101\366\001\002\000\064\043\160\044" +
    "\163\045\171\046\167\047\172\050\155\051\165\052\153" +
    "\053\156\054\173\055\170\056\174\057\164\060\161\061" +
    "\166\062\162\063\175\064\uffcb\065\157\074\uff64\076\341" +
    "\100\uffcb\101\uff64\102\340\106\uffcb\001\002\000\006\004" +
    "\336\101\uff23\001\002\000\004\101\uff6f\001\002\000\004" +
    "\101\uff76\001\002\000\004\101\uff71\001\002\000\004\101" +
    "\uff6c\001\002\000\004\101\uff72\001\002\000\004\101\uff6e" +
    "\001\002\000\004\101\uff24\001\002\000\034\053\357\054" +
    "\345\055\362\056\356\057\344\060\361\061\360\062\353" +
    "\063\354\064\347\065\352\100\217\106\uff5e\001\002\000" +
    "\006\074\uff62\101\uff62\001\002\000\006\074\uff63\101\uff63" +
    "\001\002\000\006\074\uff69\101\uff69\001\002\000\006\074" +
    "\uff66\101\uff66\001\002\000\004\106\uff83\001\002\000\004" +
    "\106\uff86\001\002\000\004\106\uff60\001\002\000\004\106" +
    "\uff7e\001\002\000\004\106\uff5f\001\002\000\036\004\074" +
    "\005\150\006\126\007\132\010\143\011\127\053\131\054" +
    "\145\056\146\057\137\064\141\066\130\070\136\072\073" +
    "\001\002\000\004\106\uff7d\001\002\000\004\106\uff80\001" +
    "\002\000\004\106\uff7f\001\002\000\004\106\363\001\002" +
    "\000\004\106\uff84\001\002\000\004\106\uff87\001\002\000" +
    "\004\106\uff81\001\002\000\004\106\uff82\001\002\000\004" +
    "\106\uff85\001\002\000\036\004\uff61\005\uff61\006\uff61\007" +
    "\uff61\010\uff61\011\uff61\053\uff61\054\uff61\056\uff61\057\uff61" +
    "\064\uff61\066\uff61\070\uff61\072\uff61\001\002\000\006\074" +
    "\uff65\101\uff65\001\002\000\006\074\uff67\101\uff67\001\002" +
    "\000\072\004\uffe3\005\uffe3\006\uffe3\007\uffe3\010\uffe3\011" +
    "\uffe3\012\uffe3\013\uffe3\017\uffe3\026\uffe3\030\uffe3\031\uffe3" +
    "\033\uffe3\036\uffe3\037\uffe3\041\uffe3\042\uffe3\053\uffe3\054" +
    "\uffe3\056\uffe3\057\uffe3\064\uffe3\066\uffe3\070\uffe3\072\uffe3" +
    "\074\uffe3\075\uffe3\101\uffe3\001\002\000\040\004\074\005" +
    "\150\006\126\007\132\010\143\011\127\053\131\054\145" +
    "\056\146\057\137\064\141\066\130\070\136\072\073\101" +
    "\uff68\001\002\000\004\074\uff3e\001\002\000\004\074\uff43" +
    "\001\002\000\040\004\074\005\150\006\126\007\132\010" +
    "\143\011\127\053\131\054\145\056\146\057\137\064\141" +
    "\066\130\070\136\072\073\101\uff39\001\002\000\004\101" +
    "\375\001\002\000\064\043\160\044\163\045\171\046\167" +
    "\047\172\050\155\051\165\052\153\053\156\054\173\055" +
    "\170\056\174\057\164\060\161\061\166\062\162\063\175" +
    "\064\uffcb\065\157\074\uff3f\076\341\100\uffcb\101\uff64\102" +
    "\340\106\uffcb\001\002\000\040\004\uff3b\005\uff3b\006\uff3b" +
    "\007\uff3b\010\uff3b\011\uff3b\053\uff3b\054\uff3b\056\uff3b\057" +
    "\uff3b\064\uff3b\066\uff3b\070\uff3b\072\uff3b\101\uff3b\001\002" +
    "\000\004\101\u0100\001\002\000\050\043\160\044\163\045" +
    "\171\046\167\047\172\050\155\051\165\052\153\053\156" +
    "\054\173\055\170\056\174\057\164\060\161\061\166\062" +
    "\162\063\175\065\157\101\uff3a\001\002\000\040\004\uff3d" +
    "\005\uff3d\006\uff3d\007\uff3d\010\uff3d\011\uff3d\053\uff3d\054" +
    "\uff3d\056\uff3d\057\uff3d\064\uff3d\066\uff3d\070\uff3d\072\uff3d" +
    "\074\uff3d\001\002\000\040\004\074\005\150\006\126\007" +
    "\132\010\143\011\127\053\131\054\145\056\146\057\137" +
    "\064\141\066\130\070\136\072\073\074\uff68\001\002\000" +
    "\004\074\uff3c\001\002\000\004\074\u0104\001\002\000\066" +
    "\004\uffe2\005\uffe2\006\uffe2\007\uffe2\010\uffe2\011\uffe2\012" +
    "\uffe2\026\uffe2\030\uffe2\031\uffe2\033\uffe2\036\uffe2\037\uffe2" +
    "\041\uffe2\042\uffe2\053\uffe2\054\uffe2\056\uffe2\057\uffe2\064" +
    "\uffe2\066\uffe2\070\uffe2\072\uffe2\074\uffe2\075\uffe2\101\uffe2" +
    "\001\002\000\004\075\u0106\001\002\000\004\101\uff42\001" +
    "\002\000\004\101\uff25\001\002\000\004\101\uff36\001\002" +
    "\000\004\101\uff30\001\002\000\004\101\uff2d\001\002\000" +
    "\004\101\uff31\001\002\000\004\101\uff2a\001\002\000\004" +
    "\101\uff28\001\002\000\004\101\uff32\001\002\000\004\101" +
    "\uff2c\001\002\000\004\101\uff33\001\002\000\004\101\uff29" +
    "\001\002\000\004\101\uff2e\001\002\000\004\101\uff2f\001" +
    "\002\000\004\101\uff2b\001\002\000\004\101\uff38\001\002" +
    "\000\006\033\uff59\074\uff57\001\002\000\004\074\u011a\001" +
    "\002\000\004\033\312\001\002\000\004\101\uff58\001\002" +
    "\000\066\004\uff56\005\uff56\006\uff56\007\uff56\010\uff56\011" +
    "\uff56\012\uff56\026\uff56\030\uff56\031\uff56\033\uff56\036\uff56" +
    "\037\uff56\041\uff56\042\uff56\053\uff56\054\uff56\056\uff56\057" +
    "\uff56\064\uff56\066\uff56\070\uff56\072\uff56\074\uff56\075\uff56" +
    "\101\uff56\001\002\000\066\004\uffe2\005\uffe2\006\uffe2\007" +
    "\uffe2\010\uffe2\011\uffe2\012\uffe2\026\uffe2\030\uffe2\031\uffe2" +
    "\033\uffe2\036\uffe2\037\uffe2\041\uffe2\042\uffe2\053\uffe2\054" +
    "\uffe2\056\uffe2\057\uffe2\064\uffe2\066\uffe2\070\uffe2\072\uffe2" +
    "\074\uffe2\075\uffe2\101\uffe2\001\002\000\004\075\u011d\001" +
    "\002\000\004\101\uff55\001\002\000\066\004\uffe2\005\uffe2" +
    "\006\uffe2\007\uffe2\010\uffe2\011\uffe2\012\uffe2\026\uffe2\030" +
    "\uffe2\031\uffe2\033\uffe2\036\uffe2\037\uffe2\041\uffe2\042\uffe2" +
    "\053\uffe2\054\uffe2\056\uffe2\057\uffe2\064\uffe2\066\uffe2\070" +
    "\uffe2\072\uffe2\074\uffe2\075\uffe2\101\uffe2\001\002\000\004" +
    "\075\u0120\001\002\000\004\101\uffe5\001\002\000\004\101" +
    "\u0127\001\002\000\064\043\160\044\163\045\171\046\167" +
    "\047\172\050\155\051\165\052\153\053\156\054\173\055" +
    "\170\056\174\057\164\060\161\061\166\062\162\063\175" +
    "\064\uffcb\065\157\074\uff5d\076\341\100\uffcb\101\uff64\102" +
    "\340\106\uffcb\001\002\000\004\074\u0124\001\002\000\066" +
    "\004\uffe2\005\uffe2\006\uffe2\007\uffe2\010\uffe2\011\uffe2\012" +
    "\uffe2\026\uffe2\030\uffe2\031\uffe2\033\uffe2\036\uffe2\037\uffe2" +
    "\041\uffe2\042\uffe2\053\uffe2\054\uffe2\056\uffe2\057\uffe2\064" +
    "\uffe2\066\uffe2\070\uffe2\072\uffe2\074\uffe2\075\uffe2\101\uffe2" +
    "\001\002\000\004\075\u0126\001\002\000\006\025\uff5c\101" +
    "\uff5c\001\002\000\036\004\074\005\150\006\126\007\132" +
    "\010\143\011\127\053\131\054\145\056\146\057\137\064" +
    "\141\066\130\070\136\072\073\001\002\000\050\043\160" +
    "\044\163\045\171\046\167\047\172\050\155\051\165\052" +
    "\153\053\156\054\173\055\170\056\174\057\164\060\161" +
    "\061\166\062\162\063\175\065\157\074\uff5b\001\002\000" +
    "\004\074\u012a\001\002\000\066\004\uffe2\005\uffe2\006\uffe2" +
    "\007\uffe2\010\uffe2\011\uffe2\012\uffe2\026\uffe2\030\uffe2\031" +
    "\uffe2\033\uffe2\036\uffe2\037\uffe2\041\uffe2\042\uffe2\053\uffe2" +
    "\054\uffe2\056\uffe2\057\uffe2\064\uffe2\066\uffe2\070\uffe2\072" +
    "\uffe2\074\uffe2\075\uffe2\101\uffe2\001\002\000\004\075\u012c" +
    "\001\002\000\006\025\uff5a\101\uff5a\001\002\000\066\004" +
    "\uffe2\005\uffe2\006\uffe2\007\uffe2\010\uffe2\011\uffe2\012\uffe2" +
    "\026\uffe2\030\uffe2\031\uffe2\033\uffe2\036\uffe2\037\uffe2\041" +
    "\uffe2\042\uffe2\053\uffe2\054\uffe2\056\uffe2\057\uffe2\064\uffe2" +
    "\066\uffe2\070\uffe2\072\uffe2\074\uffe2\075\uffe2\101\uffe2\001" +
    "\002\000\004\075\u012f\001\002\000\004\101\uff41\001\002" +
    "\000\006\033\uff53\074\uff51\001\002\000\004\033\312\001" +
    "\002\000\004\074\u0133\001\002\000\066\004\uff50\005\uff50" +
    "\006\uff50\007\uff50\010\uff50\011\uff50\012\uff50\026\uff50\030" +
    "\uff50\031\uff50\033\uff50\036\uff50\037\uff50\041\uff50\042\uff50" +
    "\053\uff50\054\uff50\056\uff50\057\uff50\064\uff50\066\uff50\070" +
    "\uff50\072\uff50\074\uff50\075\uff50\101\uff50\001\002\000\066" +
    "\004\uffe2\005\uffe2\006\uffe2\007\uffe2\010\uffe2\011\uffe2\012" +
    "\uffe2\026\uffe2\030\uffe2\031\uffe2\033\uffe2\036\uffe2\037\uffe2" +
    "\041\uffe2\042\uffe2\053\uffe2\054\uffe2\056\uffe2\057\uffe2\064" +
    "\uffe2\066\uffe2\070\uffe2\072\uffe2\074\uffe2\075\uffe2\101\uffe2" +
    "\001\002\000\004\075\u0136\001\002\000\004\101\uff4f\001" +
    "\002\000\004\101\uff52\001\002\000\064\004\uff34\005\uff34" +
    "\006\uff34\007\uff34\010\uff34\011\uff34\012\uff34\026\uff34\030" +
    "\uff34\031\uff34\033\uff34\036\uff34\037\uff27\041\uff34\042\uff34" +
    "\053\uff34\054\uff34\056\uff34\057\uff34\064\uff34\066\uff34\070" +
    "\uff34\072\uff34\074\uff34\101\uff34\001\002\000\004\037\324" +
    "\001\002\000\004\101\uff26\001\002\000\040\004\074\005" +
    "\150\006\126\007\132\010\143\011\127\053\131\054\145" +
    "\056\146\057\137\064\141\066\130\070\136\071\u013c\072" +
    "\073\001\002\000\006\074\ufff3\101\ufff3\001\002\000\004" +
    "\071\u013e\001\002\000\006\074\ufff2\101\ufff2\001\002\000" +
    "\010\013\uff47\017\uff47\075\uff47\001\002\000\004\101\u014d" +
    "\001\002\000\064\043\160\044\163\045\171\046\167\047" +
    "\172\050\155\051\165\052\153\053\156\054\173\055\170" +
    "\056\174\057\164\060\161\061\166\062\162\063\175\064" +
    "\uffcb\065\157\074\u0142\076\341\100\uffcb\101\uff64\102\340" +
    "\106\uffcb\001\002\000\010\013\uff47\017\uff47\075\uff47\001" +
    "\002\000\010\013\u0144\017\u0146\075\u0147\001\002\000\004" +
    "\105\u014b\001\002\000\010\013\uff48\017\uff48\075\uff48\001" +
    "\002\000\036\004\074\005\150\006\126\007\132\010\143" +
    "\011\127\053\131\054\145\056\146\057\137\064\141\066" +
    "\130\070\136\072\073\001\002\000\004\101\uff4b\001\002" +
    "\000\004\105\u0149\001\002\000\072\004\uffe2\005\uffe2\006" +
    "\uffe2\007\uffe2\010\uffe2\011\uffe2\012\uffe2\013\uffe2\017\uffe2" +
    "\026\uffe2\030\uffe2\031\uffe2\033\uffe2\036\uffe2\037\uffe2\041" +
    "\uffe2\042\uffe2\053\uffe2\054\uffe2\056\uffe2\057\uffe2\064\uffe2" +
    "\066\uffe2\070\uffe2\072\uffe2\074\uffe2\075\uffe2\101\uffe2\001" +
    "\002\000\010\013\uff46\017\uff46\075\uff46\001\002\000\072" +
    "\004\uffe2\005\uffe2\006\uffe2\007\uffe2\010\uffe2\011\uffe2\012" +
    "\uffe2\013\uffe2\017\uffe2\026\uffe2\030\uffe2\031\uffe2\033\uffe2" +
    "\036\uffe2\037\uffe2\041\uffe2\042\uffe2\053\uffe2\054\uffe2\056" +
    "\uffe2\057\uffe2\064\uffe2\066\uffe2\070\uffe2\072\uffe2\074\uffe2" +
    "\075\uffe2\101\uffe2\001\002\000\010\013\uff45\017\uff45\075" +
    "\uff45\001\002\000\040\004\074\005\150\006\126\007\132" +
    "\010\143\011\127\053\131\054\145\056\146\057\137\064" +
    "\141\066\130\070\136\072\073\074\u014e\001\002\000\010" +
    "\013\uff47\017\uff47\075\uff47\001\002\000\050\043\160\044" +
    "\163\045\171\046\167\047\172\050\155\051\165\052\153" +
    "\053\156\054\173\055\170\056\174\057\164\060\161\061" +
    "\166\062\162\063\175\065\157\074\u0150\001\002\000\010" +
    "\013\uff47\017\uff47\075\uff47\001\002\000\010\013\u0144\017" +
    "\u0146\075\u0152\001\002\000\004\101\uff4c\001\002\000\010" +
    "\013\u0144\017\u0146\075\u0154\001\002\000\004\101\uff49\001" +
    "\002\000\010\013\u0144\017\u0146\075\u0156\001\002\000\004" +
    "\101\uff4a\001\002\000\004\101\uffd6\001\002\000\014\004" +
    "\074\014\077\057\065\070\067\072\073\001\002\000\004" +
    "\101\uffd3\001\002\000\006\004\uffd4\071\uffd4\001\002\000" +
    "\006\004\047\071\u015d\001\002\000\004\101\u015e\001\002" +
    "\000\004\101\uffd2\001\002\000\006\004\uffd5\071\uffd5\001" +
    "\002\000\004\106\u0160\001\002\000\036\004\074\005\150" +
    "\006\126\007\132\010\143\011\127\053\131\054\145\056" +
    "\146\057\137\064\141\066\130\070\136\072\073\001\002" +
    "\000\004\101\uffd1\001\002\000\014\002\uff1d\014\uff1d\031" +
    "\uff1d\040\015\042\uff1d\001\002\000\012\002\uff1e\014\uff1e" +
    "\031\uff1e\042\uff1e\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u0161\000\006\170\004\347\003\001\001\000\004\171" +
    "\006\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\172" +
    "\012\302\013\311\015\001\001\000\002\001\001\000\004" +
    "\350\032\001\001\000\006\173\021\305\020\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\304" +
    "\024\001\001\000\004\173\025\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\020\047\036\050\044\052\037\053\041" +
    "\054\042\303\035\312\034\001\001\000\010\030\u0157\056" +
    "\u0158\213\u0156\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\030\045\061\047" +
    "\223\050\001\001\000\002\001\001\000\024\010\062\011" +
    "\071\012\074\014\077\016\070\017\100\225\067\320\065" +
    "\321\063\001\001\000\004\216\057\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\222\052\001\001\000\006" +
    "\030\045\061\053\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\216\061\001\001\000\002\001\001\000\004\224" +
    "\257\001\001\000\002\001\001\000\022\010\254\011\071" +
    "\012\074\014\077\016\070\017\100\320\065\321\063\001" +
    "\001\000\002\001\001\000\022\010\253\011\071\012\074" +
    "\014\077\016\070\017\100\320\065\321\063\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\024\247\001\001\000\002\001\001\000\002\001\001\000" +
    "\030\003\150\011\133\014\141\025\146\057\143\067\132" +
    "\072\137\107\134\117\124\320\065\321\063\001\001\000" +
    "\006\031\101\033\102\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\024\010\117\011\071\012" +
    "\074\014\077\016\070\017\100\033\121\320\065\321\063" +
    "\001\001\000\030\010\104\011\071\012\074\014\077\016" +
    "\070\017\100\030\105\034\106\035\107\320\065\321\063" +
    "\001\001\000\002\001\001\000\022\010\116\011\071\012" +
    "\074\014\077\016\070\017\100\320\065\321\063\001\001" +
    "\000\002\001\001\000\004\204\112\001\001\000\004\216" +
    "\057\001\001\000\002\001\001\000\002\001\001\000\026" +
    "\010\104\011\071\012\074\014\077\016\070\017\100\030" +
    "\105\035\114\320\065\321\063\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\030\010\122\011\071\012\074\014\077\016\070\017\100" +
    "\030\105\034\106\035\107\320\065\321\063\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\112\244\001\001\000\026\003" +
    "\150\011\133\014\141\025\241\067\132\072\137\107\134" +
    "\117\124\320\065\321\063\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\100\222\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\217\153\001\001\000\002\001\001" +
    "\000\024\003\150\011\133\014\141\067\132\072\137\107" +
    "\134\117\151\320\065\321\063\001\001\000\002\001\001" +
    "\000\026\003\150\011\133\014\141\025\220\067\132\072" +
    "\137\107\134\117\124\320\065\321\063\001\001\000\002" +
    "\001\001\000\026\003\150\011\133\014\141\025\215\067" +
    "\132\072\137\107\134\117\124\320\065\321\063\001\001" +
    "\000\026\003\150\011\133\014\141\025\214\067\132\072" +
    "\137\107\134\117\124\320\065\321\063\001\001\000\026" +
    "\003\150\011\133\014\141\025\213\067\132\072\137\107" +
    "\134\117\124\320\065\321\063\001\001\000\026\003\150" +
    "\011\133\014\141\025\212\067\132\072\137\107\134\117" +
    "\124\320\065\321\063\001\001\000\026\003\150\011\133" +
    "\014\141\025\211\067\132\072\137\107\134\117\124\320" +
    "\065\321\063\001\001\000\026\003\150\011\133\014\141" +
    "\025\210\067\132\072\137\107\134\117\124\320\065\321" +
    "\063\001\001\000\026\003\150\011\133\014\141\025\207" +
    "\067\132\072\137\107\134\117\124\320\065\321\063\001" +
    "\001\000\026\003\150\011\133\014\141\025\206\067\132" +
    "\072\137\107\134\117\124\320\065\321\063\001\001\000" +
    "\026\003\150\011\133\014\141\025\205\067\132\072\137" +
    "\107\134\117\124\320\065\321\063\001\001\000\026\003" +
    "\150\011\133\014\141\025\204\067\132\072\137\107\134" +
    "\117\124\320\065\321\063\001\001\000\026\003\150\011" +
    "\133\014\141\025\203\067\132\072\137\107\134\117\124" +
    "\320\065\321\063\001\001\000\026\003\150\011\133\014" +
    "\141\025\202\067\132\072\137\107\134\117\124\320\065" +
    "\321\063\001\001\000\026\003\150\011\133\014\141\025" +
    "\201\067\132\072\137\107\134\117\124\320\065\321\063" +
    "\001\001\000\026\003\150\011\133\014\141\025\200\067" +
    "\132\072\137\107\134\117\124\320\065\321\063\001\001" +
    "\000\026\003\150\011\133\014\141\025\177\067\132\072" +
    "\137\107\134\117\124\320\065\321\063\001\001\000\026" +
    "\003\150\011\133\014\141\025\176\067\132\072\137\107" +
    "\134\117\124\320\065\321\063\001\001\000\026\003\150" +
    "\011\133\014\141\025\175\067\132\072\137\107\134\117" +
    "\124\320\065\321\063\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\026\003" +
    "\150\011\133\014\141\025\217\067\132\072\137\107\134" +
    "\117\124\320\065\321\063\001\001\000\002\001\001\000" +
    "\002\001\001\000\040\003\150\011\133\014\141\025\227" +
    "\067\132\072\137\100\224\101\225\102\223\104\226\107" +
    "\134\117\124\231\230\320\065\321\063\001\001\000\002" +
    "\001\001\000\004\233\236\001\001\000\002\001\001\000" +
    "\004\332\233\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\331\231\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\230\235\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\034\003\150\011\133\014" +
    "\141\025\227\067\132\072\137\100\224\102\240\104\226" +
    "\107\134\117\124\320\065\321\063\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\026\003\150" +
    "\011\133\014\141\025\245\067\132\072\137\107\134\117" +
    "\124\320\065\321\063\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\022\010\252\011\071\012\074\014\077\016\070" +
    "\017\100\320\065\321\063\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\030\003\150\011\133\014" +
    "\141\025\146\057\261\067\132\072\137\107\134\117\124" +
    "\320\065\321\063\001\001\000\002\001\001\000\016\047" +
    "\036\050\044\052\037\053\041\054\042\312\263\001\001" +
    "\000\002\001\001\000\004\327\265\001\001\000\012\031" +
    "\267\033\102\064\266\226\270\001\001\000\002\001\001" +
    "\000\004\330\271\001\001\000\002\001\001\000\004\065" +
    "\273\001\001\000\006\042\275\211\274\001\001\000\002" +
    "\001\001\000\100\003\150\011\303\014\141\025\325\043" +
    "\324\044\334\047\330\050\044\052\037\067\132\072\137" +
    "\107\134\117\124\120\327\121\321\122\322\124\277\125" +
    "\333\126\331\127\302\131\332\134\300\135\316\136\306" +
    "\137\313\145\315\147\310\266\307\320\065\321\063\322" +
    "\305\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\030\003\150\011\133\014" +
    "\141\025\u0140\067\132\072\137\107\134\117\124\122\u013f" +
    "\320\065\321\063\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\030\003\150\011" +
    "\133\014\141\025\u0121\067\132\072\137\107\134\117\124" +
    "\122\u0120\320\065\321\063\001\001\000\004\326\u011d\001" +
    "\001\000\002\001\001\000\030\003\150\011\133\014\141" +
    "\025\146\057\u0114\067\132\072\137\107\134\117\124\320" +
    "\065\321\063\001\001\000\072\003\150\011\303\014\141" +
    "\025\325\044\u0113\047\u010f\050\044\052\037\067\132\072" +
    "\137\107\134\117\124\120\u010e\121\u010c\122\u010d\124\u0108" +
    "\125\u0112\126\u0111\127\u0109\131\u0110\135\u010b\136\306\137" +
    "\313\145\315\147\310\320\065\321\063\322\u010a\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\343\366\001\001" +
    "\000\002\001\001\000\010\217\336\245\342\317\341\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\005\345\006\347" +
    "\007\350\246\354\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\032\003\150\011\303\014\141\025\146" +
    "\057\364\067\132\072\137\107\134\117\124\320\065\321" +
    "\063\322\363\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\036\003\150\011\133\014\141" +
    "\025\373\067\132\072\137\107\134\117\124\122\372\160" +
    "\367\265\370\320\065\321\063\324\371\001\001\000\002" +
    "\001\001\000\004\344\u0102\001\001\000\030\003\150\011" +
    "\133\014\141\025\376\067\132\072\137\107\134\117\124" +
    "\271\375\320\065\321\063\001\001\000\002\001\001\000" +
    "\010\217\336\245\342\317\341\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\345\u0100\001" +
    "\001\000\030\003\150\011\133\014\141\025\325\067\132" +
    "\072\137\107\134\117\124\122\u0101\320\065\321\063\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\042\u0104" +
    "\211\274\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\335\u0117\336\u0116" +
    "\001\001\000\002\001\001\000\010\135\u0118\136\306\137" +
    "\313\001\001\000\002\001\001\000\004\337\u011a\001\001" +
    "\000\006\042\u011b\211\274\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\042\u011e\211\274\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\217" +
    "\336\245\342\317\341\333\u0122\001\001\000\002\001\001" +
    "\000\006\042\u0124\211\274\001\001\000\002\001\001\000" +
    "\002\001\001\000\026\003\150\011\133\014\141\025\u0127" +
    "\067\132\072\137\107\134\117\124\320\065\321\063\001" +
    "\001\000\004\334\u0128\001\001\000\002\001\001\000\006" +
    "\042\u012a\211\274\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\042\u012d\211\274\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\340\u0130\341\u0131\001\001\000" +
    "\010\135\u0136\136\306\137\313\001\001\000\002\001\001" +
    "\000\004\342\u0133\001\001\000\006\042\u0134\211\274\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\346\u0138\001\001\000\006\134\u0139\266\307\001" +
    "\001\000\002\001\001\000\030\003\150\011\133\014\141" +
    "\025\146\057\u013c\067\132\072\137\107\134\117\124\320" +
    "\065\321\063\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\254\u0154\001\001\000\002\001" +
    "\001\000\010\217\336\245\342\317\341\001\001\000\004" +
    "\254\u0142\001\001\000\004\151\u0144\001\001\000\002\001" +
    "\001\000\002\001\001\000\030\003\150\011\133\014\141" +
    "\025\146\057\u0147\067\132\072\137\107\134\117\124\320" +
    "\065\321\063\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\042\u0149\211\274\001\001\000\002\001\001\000" +
    "\006\042\u014b\211\274\001\001\000\002\001\001\000\026" +
    "\003\150\011\133\014\141\025\u014e\067\132\072\137\107" +
    "\134\117\124\320\065\321\063\001\001\000\004\254\u0152" +
    "\001\001\000\002\001\001\000\004\254\u0150\001\001\000" +
    "\004\151\u0144\001\001\000\002\001\001\000\004\151\u0144" +
    "\001\001\000\002\001\001\000\004\151\u0144\001\001\000" +
    "\002\001\001\000\002\001\001\000\022\010\u015e\011\071" +
    "\012\074\014\077\016\070\017\100\320\065\321\063\001" +
    "\001\000\002\001\001\000\004\212\u015a\001\001\000\006" +
    "\030\u0157\056\u015b\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\030\003\150" +
    "\011\133\014\141\025\146\057\u0160\067\132\072\137\107" +
    "\134\117\124\320\065\321\063\001\001\000\002\001\001" +
    "\000\006\172\012\311\u0162\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


 
  public Parser(ScannerLex lex) {
    super(lex);
  }
  public static void main(String[] args)
  {
     try
     {
         ScannerLex scanner = new ScannerLex(new BufferedReader(new FileReader(args[0])));
     System.out.println("Start parsing \"" + args[0] + "\"...");
        
        // start parsing
        Parser p = new Parser(scanner);
     System.out.println("Nearing end \"" + args[0] + "\"...");
        Symbol s = p.debug_parse();
     }
     catch(Exception e)
     {
          e.printStackTrace();
     }
  }
  

  public void print_x86_to_file(LinkedList<Tac> x86_array, String fileName) 
  {

    try
    {
        PrintWriter writer = new PrintWriter(fileName);

        Tac new_entry = new Tac();

        for(int i=0;i<x86_array.size();++i)
        {
          new_entry = x86_array.get(i);

          writer.print(new_entry.res);
          if ( new_entry.op1 == null && new_entry.op2 == null && new_entry.opr == null )
          {
            writer.println();
            continue;
          }
          if ( new_entry.op1 != null )
          {
            writer.print(" "+new_entry.op1);  
          }
          if ( new_entry.opr != null && new_entry.opr != "=" )
          {
            writer.print(" "+new_entry.opr);
          }
          if ( new_entry.op2 != null )
            writer.print(", "+new_entry.op2);

          writer.println();
        }

        writer.close();     
    }
    catch (FileNotFoundException ex)  
    {
         System.out.println("\n\n\n UNABLE TO WRITE TO "+fileName+"\n\n\n");
        // insert code to run when exception occurs
    }

  }

  public void print_irgen_to_file(LinkedList<Tac> ir_array, String fileName) 
  {

    try
    {
        PrintWriter writer2 = new PrintWriter(fileName);

        Tac new_entry = new Tac();

        for(int i=0;i<ir_array.size();++i)
        {

          new_entry = ir_array.get(i);

          writer2.print(new_entry.res);


          if ( new_entry.op1 == null && new_entry.op2 == null && new_entry.opr == null )
          {
            writer2.println();
            continue;
          }
          if ( new_entry.opr == null )
          {
            writer2.print(" =");
          }
          else if ( new_entry.opr.matches("env<([0-9])*>") ||  new_entry.opr == "goto" || GoConstants.checkIfTacReserved(new_entry.res) )
          {
             // do nothing
          }
          else
          {
            writer2.print(" ="); // since opr is not null
          }
          
          if ( new_entry.op1 != null )
          {
            writer2.print(" "+new_entry.op1);  
          }
          if ( new_entry.opr != null && new_entry.opr != "=" )
          {
            writer2.print(" "+new_entry.opr);
          }
          if ( new_entry.op2 != null )
            writer2.print(" "+new_entry.op2);

          writer2.println();
        }

        writer2.close();     
    }
    catch (FileNotFoundException ex)  
    {
         System.out.println("\n\n\n UNABLE TO WRITE TO "+fileName+"\n\n\n");
        // insert code to run when exception occurs
    }

  }



  LinkedList<Tac> x86_array = new LinkedList<Tac>();
  LinkedList<SimpleBlock> simple_blocks = new LinkedList<SimpleBlock>();
  Env top; 
  int indexSym_counter = 0;
  public String next_env_name(int is_stop)
  {

    if(is_stop==0)
      indexSym_counter++;
    
    return "env<"+indexSym_counter+">";
  }
  public void print_sym_table()
  {

 
    for(Env e=top; e!=null;e=e.get_prev())
    {
        Set set = e.table.entrySet();
        Iterator it = set.iterator();
        while (it.hasNext()) {
          Map.Entry entry = (Map.Entry) it.next();
          System.out.println(entry.getKey() + " : " + ((SymbolTableEntry)entry.getValue()).printOb());
        }
        System.out.println("Changing Tables");
     }   
  
  
  }

  public void print_this_sym_table(Env e)
  {
    Set set = e.table.entrySet();
    Iterator it = set.iterator();
    while (it.hasNext()) {
      Map.Entry entry = (Map.Entry) it.next();
      System.out.println(entry.getKey() + " : " + ((SymbolTableEntry)entry.getValue()).printOb());
    }
  }

  LinkedList<Tac> quad_array = new LinkedList<Tac>();
 
  Map global_registers = new HashMap();
  
  public void gen_registers()
  {
    for(int i=0; i<GoConstants.REGISTERNAMES.size();++i)
    {
      global_registers.put(GoConstants.REGISTERNAMES.get(i), new Register(GoConstants.REGISTERNAMES.get(i)));
    }
  }

  int temp_counter=0;
  public String next_temp(String dataType)
  {
    temp_counter++;
    dataType = get_type_from_symboltable(dataType);
    SymbolTableEntry s = new SymbolTableEntry(dataType, top.global_offset);

    top.global_offset += s.size;

    top.put("t<"+temp_counter+">", s);
    // SymbolTableEntry s =new SymbolTableEntry();

    return "t<"+temp_counter+">";

  }

  int label_counter = 0;
  public String next_label()
  {
    label_counter++;
    return "l<"+label_counter+">";

  }
              
  public void print_qaud_array()
  {
    print_irgen_to_file(quad_array, "ircode.ir");
    for(int i=0;i<quad_array.size();++i)
    {
      System.out.print(i+"\t");
      quad_array.get(i).print_tac();
    }
  }
  public void print_next_array(LinkedList<Tac> sent_array)
  {
    for(int i=0;i<sent_array.size();++i)
    {
      sent_array.get(i).print_tac_machine();
    }
  }
  public void print_registers()
  {
    for(int i=0; i<GoConstants.REGISTERNAMES.size();++i)
    {
       ((Register)(global_registers.get(GoConstants.REGISTERNAMES.get(i)))).print_reg();
      // global_registers.put(GoConstants.REGISTERNAMES.get(i), new Register(GoConstants.REGISTERNAMES.get(i)));
    }
  }

  // Tac quad_array[] = new ArrayList<Tac>();

    public String get_type_from_symboltable(String id)
    {

      if ( id.contains(":") == false )
      {
        if ( top.getQuiet(id) != null )
        {
          return top.getQuiet(id).parsedDataType;
        }
        else
          return id;
      }
      List<String> allid = Arrays.asList(id.split(":"));

      List<String> alltype = new ArrayList<String>();

      for ( int i = 0; i < allid.size(); i++ )
      {
        if ( top.getQuiet(allid.get(i)) != null )
        {
          alltype.add(top.getQuiet(allid.get(i)).parsedDataType);
        }
        else
        {
          alltype.add(allid.get(i));
        }
      }


      for ( int i = 0; i < alltype.size()-1; i++ )
      {
        // Type1_Contains_Type2(alltype.get(i), alltype.get(i+1) );
        if ( alltype.get(i).equals(alltype.get(i+1)) == false )
        {
           System.out.println("ERROR: type "+alltype.get(i)+" does not match type "+alltype.get(i+1));
           return null;
        }
        else
        {
           // System.out.println("CORRECT: type "+alltype.get(i)+" does match type "+alltype.get(i+1));
        }
      }

      return alltype.get(0);

    }
    public boolean is_label(String sent)
    { 

      if(sent!=null && (sent.substring(sent.length() - 1)).equals(":") )
        return true;

      return false;
    }
    public boolean is_temp(String sent)
    {
      if(sent!=null && sent.matches("t<([0-9])*>"))
        return true;
      return false;
    }
    public boolean is_sp_labels(String sent, String opr)
    {
      if(sent!=null && opr!=null && opr.equals("goto"))
        return true;
      return false;
    }
    public boolean is_var(String sent)//opr is required for goto
    {
      // if(sent!=null && !is_label(sent) && !is_temp(sent) && !is_sp_labels(sent,opr) && !GoConstants.checkIfTacReserved(sent) )
      if(sent!=null && sent.matches("#(.*)#"))
        return true;
      return false;
    }
    public String strip_tac_identifier(String id )
    {
        return id.substring(1,id.length() - 1);
    }
    public void next_step()//called at the end of the source file reduction
    {
      

      for ( Object key : Env.indexSym.keySet() ) 
      {
          System.out.println( (String)key );
          print_this_sym_table((Env)Env.indexSym.get((String)key));
      }

      print_qaud_array();

      LinkedList<String> symbolTablesNames = new LinkedList<String>();
      // LinkedList symbolTablesNames_copy = new LinkedList<String>();

      for(int i=0;i<quad_array.size();++i)
      {
        if(is_label(quad_array.get(i).res))
        {
          symbolTablesNames.addFirst(quad_array.get(i).opr);
          // symbolTablesNames_copy.addFirst(quad_array.get(i).opr);
        }
      }
      
      System.out.println("SYMBOL TABLE NAMES: ");
      for(int i=0;i<symbolTablesNames.size();++i)
      {
        System.out.println(i+": "+symbolTablesNames.get(i));
        
      }


      //Now I have the symbolTbale stack
      // symbolTablesNames_copy = symbolTablesNames;
      //Now I have to start reading from backward
      LinkedList<TacLineInfo> tacline_array = new LinkedList<TacLineInfo>();
      // LinkedList<SimpleBlock> simple_blocks = new LinkedList<SimpleBlock>();
      Env curr_symbol_table;
      curr_symbol_table = (Env)(Env.indexSym.get(symbolTablesNames.pop()));
      for(int i=quad_array.size()-1 ; i>=0 ; i--)
      {
        //if current statement is block start I change the symbol table and also start a new block and append the last one to the linkedlist
        Tac curr_quad_entry = quad_array.get(i);
        if( is_label(curr_quad_entry.res) )
        {
            
          // System.out.println(":::::: i is ::: "+i);
          SimpleBlock new_block = new SimpleBlock(curr_quad_entry.res,curr_symbol_table.get_name(),tacline_array);
          simple_blocks.addFirst(new_block);
          tacline_array = new LinkedList<TacLineInfo>();//this may be costly in future

          if(curr_quad_entry.res.equals("GLOBAL:"))
              break;
          curr_symbol_table = (Env)(Env.indexSym.get(symbolTablesNames.pop()));
        }
        
        else //else we do as given in the book
        {
          // if()
          TacLineInfo new_tac_line = new TacLineInfo();
          if(is_var(curr_quad_entry.res)) //checking is res is really a variable
          {

              //Still have to write code for adding nextuse info
              curr_quad_entry.res = strip_tac_identifier(curr_quad_entry.res);
              // System.out.println()
              Map asli_info = new HashMap();

              SymbolTableEntry var_symboltableentry = curr_symbol_table.getFromThisEnv(curr_quad_entry.res);
              if ( var_symboltableentry != null ) // if it is not in current table, then no need to search in parents and then update it in your own table
              {
                asli_info.put("live",var_symboltableentry.live);
                asli_info.put("next_use",var_symboltableentry.next_use);
                new_tac_line.line_info.put(curr_quad_entry.res,asli_info);//==> map of variable_name : asli_info

                var_symboltableentry.live = false;
                var_symboltableentry.next_use = -1;
                System.out.println("1 "+curr_symbol_table.envName+" updating in its table var "+curr_quad_entry.res);
                curr_symbol_table.update(curr_quad_entry.res,var_symboltableentry);
              }

          }
          if(is_var(curr_quad_entry.op1))
          {
            curr_quad_entry.op1 = strip_tac_identifier(curr_quad_entry.op1);

            Map asli_info = new HashMap();
            SymbolTableEntry var_symboltableentry = curr_symbol_table.getFromThisEnv(curr_quad_entry.op1);
            if ( var_symboltableentry != null ) // if it is not in current table, then no need to search in parents and then update it in your own table
            {
              asli_info.put("live",var_symboltableentry.live);
              asli_info.put("next_use",var_symboltableentry.next_use);
              new_tac_line.line_info.put(curr_quad_entry.op1,asli_info);//==> map of variable_name : asli_info

              var_symboltableentry.live = true;
              var_symboltableentry.next_use = i;
              System.out.println("2 "+curr_symbol_table.envName+" updating in its table var "+curr_quad_entry.op1);
              curr_symbol_table.update(curr_quad_entry.op1,var_symboltableentry);
            }
          }
          if(is_var(curr_quad_entry.op2))
          {
            curr_quad_entry.op2 = strip_tac_identifier(curr_quad_entry.op2);
            
            Map asli_info = new HashMap();
            SymbolTableEntry var_symboltableentry = curr_symbol_table.getFromThisEnv(curr_quad_entry.op2);
            if ( var_symboltableentry != null ) // if it is not in current table, then no need to search in parents and then update it in your own table
            {
              asli_info.put("live",var_symboltableentry.live);
              asli_info.put("next_use",var_symboltableentry.next_use);
              new_tac_line.line_info.put(curr_quad_entry.op2,asli_info);//==> map of variable_name : asli_info

              var_symboltableentry.live = true;
              var_symboltableentry.next_use = i;
              
              System.out.println("3 "+curr_symbol_table.envName+" updating in its table var "+curr_quad_entry.op2);

              curr_symbol_table.update(curr_quad_entry.op2,var_symboltableentry);
            }
          }

          if(is_temp(curr_quad_entry.res)) //checking is res is really a temp
          {

              //Still have to write code for adding nextuse info
              // System.out.println()
              Map asli_info = new HashMap();

              SymbolTableEntry var_symboltableentry = curr_symbol_table.getFromThisEnv(curr_quad_entry.res);
              if ( var_symboltableentry != null ) // if it is not in current table, then no need to search in parents and then update it in your own table
              {
                asli_info.put("live",var_symboltableentry.live);
                asli_info.put("next_use",var_symboltableentry.next_use);
                new_tac_line.line_info.put(curr_quad_entry.res,asli_info);//==> map of temp_name : asli_info

                var_symboltableentry.live = false;
                var_symboltableentry.next_use = -1;
                
                System.out.println("4 "+curr_symbol_table.envName+" updating in its table temp "+curr_quad_entry.res);

                curr_symbol_table.update(curr_quad_entry.res,var_symboltableentry);
              }
          }
          if(is_temp(curr_quad_entry.op1))
          {

            Map asli_info = new HashMap();
            SymbolTableEntry var_symboltableentry = curr_symbol_table.getFromThisEnv(curr_quad_entry.op1);
            if ( var_symboltableentry != null ) // if it is not in current table, then no need to search in parents and then update it in your own table
            {
              asli_info.put("live",var_symboltableentry.live);
              asli_info.put("next_use",var_symboltableentry.next_use);
              new_tac_line.line_info.put(curr_quad_entry.op1,asli_info);//==> map of temp_name : asli_info

              var_symboltableentry.live = true;
              var_symboltableentry.next_use = i;

              System.out.println("5 "+curr_symbol_table.envName+" updating in its table temp "+curr_quad_entry.op1);

              curr_symbol_table.update(curr_quad_entry.op1,var_symboltableentry);
            }
          }
          if(is_temp(curr_quad_entry.op2))
          {
            
            Map asli_info = new HashMap();
            SymbolTableEntry var_symboltableentry = curr_symbol_table.getFromThisEnv(curr_quad_entry.op2);
            if ( var_symboltableentry != null ) // if it is not in current table, then no need to search in parents and then update it in your own table
            {
              asli_info.put("live",var_symboltableentry.live);
              asli_info.put("next_use",var_symboltableentry.next_use);
              new_tac_line.line_info.put(curr_quad_entry.op2,asli_info);//==> map of temp_name : asli_info

              var_symboltableentry.live = true;
              var_symboltableentry.next_use = i;

              System.out.println("6 "+curr_symbol_table.envName+" updating in its table temp "+curr_quad_entry.op2);

              curr_symbol_table.update(curr_quad_entry.op2,var_symboltableentry);
            }
          }
         /* if(is_label(curr_quad_entry.res) || is_sp_labels(curr_quad_entry.res))
          {
            curr_quad_entry.res = 
          }*/
          new_tac_line.line = curr_quad_entry;
          tacline_array.addFirst(new_tac_line);
        }
      }

      System.out.println("Printing before sorting env tables: ");
      for(Object key : Env.indexSym.keySet())
      {
          ((Env)(Env.indexSym.get(key))).print_this_symTable();        
      }
      System.out.println("Ending Printing env tables\n\n\n ");

      Tac first_entry = new Tac();
      first_entry.res="section .text\n\nextern printf\n\nglobal main\n\n";
      x86_array.add(first_entry);

           /*   int global_ebp=0,global_esp=0;
                LinkedList<Stack> stack_list = new LinkedList<Stack>();
           */
      // A<Int> func_memories = new LinkedList<Int>();
      int temp_func_memory=0;

      SortedSet<String> keys = new TreeSet<String>(Env.indexSym.keySet());
      Map func_memory_map =  new HashMap();
      String prev_key = null;
      String prev_label_name = null;

      int ias = 0;
      for(String key : keys)
      {
        // if()
        //TODO handle for different functions
        // String label_name=null;
        // System.out.println("finding env :::: "+key);

        // for(ias=0;ias<simple_blocks.size();++ias)
        // {
        //   label_name = simple_blocks.get(ias).label_name;
        //   System.out.println("label :::: "+label_name+" memory is : "+temp_func_memory );

        //   if(simple_blocks.get(ias).symbolTable_name.equals(key) && label_name.matches("_(.*)"))
        //   {
        //     // label_name=simple_blocks.get(i).label_name;
        //     // ((Env)Env.indexSym.get(prev_key)).incr_global_offset=temp_func_memory;
          
        //     System.out.println("func :::: "+label_name+" has memory: "+temp_func_memory+"\n\n" );

        //     if ( prev_label_name != null )
        //     {
        //         func_memory_map.put(prev_label_name, temp_func_memory);
        //     }
            
        //     temp_func_memory=0;
        //     prev_label_name = label_name;

        //     for(Object key2 : func_memory_map.keySet())
        //     {
        //       // if()
        //       //TODO handle for different functions
        //       // ((Env)Env.indexSym.getkey)).incr_global_offset=temp_func_memory;
        //       // temp_func_memory += ((Env)Env.indexSym.get(key)).global_offset;
        //       System.out.println("func from map :::: "+key2+" has memory: "+func_memory_map.get(key2) );
              
        //     }
        //     break;
        //   }
        // }
        /*if ( label_name.matches("_(.*)") )
        {
          temp_func_memory=0;
        }*/
        // prev_key = key;

        ((Env)Env.indexSym.get(key)).incr_global_offset=temp_func_memory;
        temp_func_memory += ((Env)Env.indexSym.get(key)).global_offset;
        
        // System.out.println("env :::: "+((Env)Env.indexSym.get(key)).envName+" incr_global_offset is : "+((Env)Env.indexSym.get(key)).incr_global_offset+ " temp_func_memory "+temp_func_memory );

        // System.out.println("ENV:::: "+key+" has incr_global_offset: "+((Env)Env.indexSym.get(key)).incr_global_offset);
        
      }

      // func_memory_map.put(simple_blocks.get(ias).label_name, temp_func_memory);
      // ((Env)Env.indexSym.get(prev_key)).incr_global_offset=temp_func_memory;

      // for(Object key2 : func_memory_map.keySet())
      // {
      //   // if()
      //   //TODO handle for different functions
      //   // ((Env)Env.indexSym.getkey)).incr_global_offset=temp_func_memory;
      //   // temp_func_memory += ((Env)Env.indexSym.get(key)).global_offset;
      //   System.out.println("func from map :::: "+key2+" has memory: "+func_memory_map.get(key2) );
        
      // }



      for(Object key : Env.indexSym.keySet())
      {
        // if()
        //TODO handle for different functions
        // ((Env)Env.indexSym.getkey)).incr_global_offset=temp_func_memory;
        // temp_func_memory += ((Env)Env.indexSym.get(key)).global_offset;
        System.out.println("ENV:::: "+key+" has incr_global_offset: "+((Env)Env.indexSym.get(key)).incr_global_offset);
        
      }

      boolean funcBlockFirstTime = true;
      for(int i=1;i<simple_blocks.size();++i)
      {
          /*int ebp=0, esp=0;
          int flag=0;
          int sizeblock=0;
          Env symTable;
          */
          // symTable=((Env)Env.indexSym.get(simple_blocks.get(i).symbolTable_name);

          SimpleBlock curr_block = simple_blocks.get(i);
          
          LinkedList<TacLineInfo> lines = curr_block.lines;
          LinkedList<Tac> x86_array_deferred = new LinkedList<Tac>();
          if(curr_block.label_name.matches("_(.*)"))
          {

            Tac new_entry = new Tac();
          
            String funcNameWithFirstUnderScore = curr_block.label_name;

            new_entry.res= funcNameWithFirstUnderScore.substring(1);  // removing the first underscore only (not other underscores given by user in golang file)
            System.out.println("@@ISHAAN@@"+new_entry.res);
            x86_array.add(new_entry);

            if(new_entry.res.equals("println:"))
            {
              Tac new_entry99= new Tac();
              new_entry99.res="push DWORD [esp+4]\npush message\ncall printf\nadd esp,8\nret";
              x86_array.add(new_entry99);
              continue;
            }
            x86_array_deferred.clear();
            // new_entry.res = curr_block.label_name;

            if ( funcBlockFirstTime == false )  // so we have to pop the function. TODO: don't pop main
            {

              // ALREADY HANDLED BY getx86()

              // mov esp, ebp
              // pop ebp
              // Tac new_entry22 = new Tac();
              // new_entry22.res="mov";
              // new_entry22.op1="esp";
              // new_entry22.op2 = "ebp";
              // x86_array.add(new_entry22);

              // Tac new_entry23 = new Tac();
              // new_entry23.res= "pop";
              // new_entry23.op1 = "ebp";
              // x86_array.add(new_entry23);

            }

            funcBlockFirstTime = false; // since we visited it this time, so when we visit again, it won't be first time

            Tac new_entry21 = new Tac();
            new_entry21.res= "push";
            new_entry21.op1 = "ebp";
            x86_array.add(new_entry21);

            Tac new_entry3 = new Tac();
            new_entry3.res="mov";
            new_entry3.op1="ebp";
            new_entry3.op2 = "esp";
            x86_array.add(new_entry3);

            Tac new_entry2 = new Tac();
            new_entry2.res= "sub";
            new_entry2.op1 = "esp";
            new_entry2.op2=  String.valueOf(temp_func_memory); // String.valueOf((int)func_memory_map.get(funcNameWithFirstUnderScore) );  //String.valueOf(((Env)Env.indexSym.get(curr_block.symbolTable_name)).incr_global_offset);     //String.valueOf(temp_func_memory);
            x86_array.add(new_entry2);
          }
          else // since we are starting a new simple block, so we have a new label. so add it to x86. Also it is not of a function as it is handled in if case
          {
            Tac new_entry = new Tac();
          
            new_entry.res= curr_block.label_name.replace("<","");
            new_entry.res = new_entry.res.replace(">","");
            
            // new_entry.res = curr_block.label_name;
            x86_array.add(new_entry);
          }

          int numSpillsInSimpleBlock = 0;
          for(int j=0;j<lines.size();++j)
          {
            numSpillsInSimpleBlock += getx86(lines.get(j),x86_array, (Env)(Env.indexSym.get(curr_block.symbolTable_name)),x86_array_deferred );
          }

          // We need to spill all registers to memory before moving to the next simple block.
          // But we may be having goto statements at the end of the previous simple blocks in which
          // case spilling registers after it will be useless (we won't be reaching here in assembly!)

          // So this spilling business should be done by getx86 itself in goto

          if ( numSpillsInSimpleBlock == 0 )
          {
            for(Object key : global_registers.keySet())
            {
              x86_array.addAll( ((Register)(global_registers.get((String)key))).spill(""));
            }
          }
      }


      // Tac new_entry3 = new Tac();
      // new_entry3.res="mov";
      // new_entry3.op2="ebp";
      // new_entry3.op1 = "esp";
      // x86_array.add(new_entry3);



      

      // Tac new_entry2 = new Tac();
      // new_entry2.res= "sub";
      // new_entry2.op1 = "esp";
      // new_entry2.op2= String.valueOf(temp_func_memory);
      // x86_array.add(new_entry2);

      //Now i have the simple blocks 
      Tac global_data = new Tac();

      global_data.res="\n\n\nmov esp, ebp\npop ebp\nret\n\n\nMensagem do BD \n";
      global_data.op1 =""; 

      Env global_table =  (Env)(Env.indexSym.get(simple_blocks.get(0).symbolTable_name));
      for(Object key : global_table.table.keySet())
      {
        if(is_var((String)key))
          global_data.op1 += (String)key+ " DB "+global_table.get((String)key).size+"\n";
        
      }
      x86_array.add(global_data);


      print_qaud_array();
      print_next_array(x86_array);


      print_x86_to_file(x86_array, "x86code.asm");




     /* LinkedList<Tac> next_array = new LinkedList<Tac>();

      for(int i=0;i<quad_array.size();++i)
      {
          Tac next_entry =  new Tac();
          if(i==0 && is_label(quad_array.get(i).res)==false )
          {
            next_entry.res = "<BLOCK START>";
            next_array.add(next_entry);
            next_array.add(quad_array.get(i));
          }
          else if(is_label(quad_array.get(i).res)==true)
          {
            next_entry.res = "<BLOCK START>";
            next_array.add(next_entry);
            next_array.add(quad_array.get(i));

          }
          else if(quad_array.get(i).opr!=null && quad_array.get(i).opr.equals("goto"))
          {
            next_array.add(quad_array.get(i));
            next_entry.res = "<BLOCK START>";
            next_array.add(next_entry);
          }
          else
            next_array.add(quad_array.get(i));
            
          //Debating whether to use own data structure to propagate next use info. or
          // revive symbol table.
      }*/
      // print_next_array(next_array);
     /* System.out.println("***************");
      for(int i=0;i<simple_blocks.size();++i)
      {
        // System.out.println("\n********"++"*******\n");
        simple_blocks.get(i).print_block();

      }*/

      

    }

    // This returns 1 if spilling of registers has been done by it
    // otherwise returns 0
    public int getx86(TacLineInfo tac_line_info, LinkedList<Tac> x86_array,Env symbolTable,LinkedList<Tac> x86_array_deferred)
    {
      Tac line = tac_line_info.line;
      // Map registers = getReg(tac_line_info);
      Register res_register, op2_register;
       Register op1_register ;

            System.out.print("LINE RECIEVED ");
            // line.print_tac();
            System.out.print(line.res+" : "+line.op1+" : "+line.opr+" : "+line.op2);

      int returnValue = 0;

      Tac new_entry = new Tac();
      
      if ( line.opr != null )
      {
          if ( line.opr == "=" )
          { 

            // if ( line.op2 != null ) // we have array's index in op2
            // {
              
            // }

            
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array);
            SymbolTableEntry s = symbolTable.get(line.res);

            new_entry.res = "mov";
            
            if(op1_register == null) //we have i= const
            {
              res_register = getReg(line.res,0,symbolTable,line,x86_array);
              

              new_entry.op1 = res_register.name;
              new_entry.op2 = line.op1;
              int size = symbolTable.get(line.res).get_default_size();
              String type="ERROR";
              if(size==1)
                type = "BYTE";
              else if(size==2)
                type="WORD";
              else if(size==4)
                type="DWORD";
              else
                System.out.println("ERROR : WORD SIZE "+size+" NOT SUPPORTED");
              new_entry.res = "mov";//+type;
            }
            else
            {
              res_register = op1_register;
              new_entry.op1 = res_register.name;
              new_entry.op2 = op1_register.name;
              

              s.fix_reg_addrDesc(res_register.name, global_registers, line.res);


              Map reg_map = new HashMap();//variable-> symboltable
              reg_map.put(line.op1,symbolTable);
              op1_register.add_to_regdesc(reg_map);

              SymbolTableEntry s2= new SymbolTableEntry();
              s2 = symbolTable.get(line.op1);

              s2.add_to_addrdesc(op1_register.name,line.op1);
              symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);

              symbolTable.get(line.op1).print_addrDesc(line.op1);
            }

            
            s.add_to_addrdesc(res_register.name,line.res);
            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            // if(symbolTable.get(line.res).addressDescriptor.indexOf(res_register.name)!=-1)
              // symbolTable.get(line.res).addressDescriptor.addFirst(res_register.name);

            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);

            if ( new_entry.op1.equals(new_entry.op2) == false )
            {
              x86_array.add(new_entry);
            }
            print_registers();

            symbolTable.get(line.res).print_addrDesc(line.res);

            //Handled only reg->reg or const->reg
          }
            /*  else if (  line.opr == "goto" )//|| res == "push" || res == "call" || res == "import" || res == "package" )
              {
              // do nothing
              new_entry.res = "goto";
              new_entry.op1 = line.res;
              x86_array.add(new_entry);
            }*/
          else if ( line.opr == "+" )
          {
            //Tac new_entry = new Tac();
            
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+ symbolTable.get_real_offset(line.res) +"]";

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "add";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in add, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);

          } 
          else if ( line.opr == "-" )
          {
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+ symbolTable.get_real_offset(line.res)+"]";

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "sub";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in sub, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);
          }
          else if ( line.opr == "*" )
          {
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+ symbolTable.get_real_offset(line.res)+"]";

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "imul";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in imul, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);  
          }
          else if ( line.opr == "/" || line.opr == "%" )
          {
              

            //edx : line.op1
            //empty register and
            x86_array.addAll(((Register)global_registers.get("edx")).spill(""));
            x86_array.addAll(((Register)global_registers.get("eax")).spill(""));

            // op1_register = getReg(line.op1,1,symbolTable,line,x86_array);
            String op1_reg_name = symbolTable.get(line.op1).get_prev_register();
            if(op1_reg_name!=null)
            {
              Tac new_entry3 = new Tac();
              new_entry3.res = "mov";
              new_entry3.op1 = "edx";
              new_entry3.op2 = op1_reg_name;
              x86_array.add(new_entry3);
            }
            else
            {
              Tac new_entry3 = new Tac();
              new_entry3.res = "mov";
              new_entry3.op1 = "edx";
              new_entry3.op2 = "[ebp-"+ symbolTable.get_real_offset(line.op1)+"]";

              x86_array.add(new_entry3); 
            }


            Tac new_entry2 = new Tac();
            new_entry2.res="idiv";
            String op2_reg_name = symbolTable.get(line.op2).get_prev_register();
            if(op2_reg_name!=null)
            {
              new_entry2.op1 = op2_reg_name;
            }
            else
            {
              new_entry2.op1 = "[ebp-"+ symbolTable.get_real_offset(line.op2)+"]";
            }
            x86_array.add(new_entry2);


            new_entry.res ="mov";

            String res_reg_name = symbolTable.get(line.res).get_prev_register();
            if(res_reg_name==null)
            {
              new_entry.op1 = "[ebp-"+ symbolTable.get_real_offset(line.res)+"]";
              SymbolTableEntry s = symbolTable.get(line.res);
              s.add_to_addrdesc("[ebp-"+ symbolTable.get_real_offset(line.res)+"]",line.res);
              symbolTable.updateInEnv_whereVarActuallyIs(line.res,s);
              // s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            }
            else
            {
              new_entry.op1 = res_reg_name;
            }

            if(line.opr=="%")
            {
              //ans in edx
              new_entry.op2="edx";
            }
            else
            {
              //ans in eax
              new_entry.op2="eax";
            }
            x86_array.add(new_entry);

          }
          else if ( line.opr == "&" || line.opr == "&&" )
          {
            //Tac new_entry = new Tac();
             
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+ symbolTable.get_real_offset(line.res)+"]";

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "and";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in add, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);    
          }
          else if ( line.opr == "|" || line.opr == "||" )
          {
            //Tac new_entry = new Tac();
           new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+ symbolTable.get_real_offset(line.res)+"]";

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "or";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in add, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);    
          }
          else if ( line.opr == "^" )
          {
            //Tac new_entry = new Tac();
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+ symbolTable.get_real_offset(line.res)+"]";

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "xor";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in add, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);       
          }
          else if ( line.opr == ">>" )
          {
            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            x86_array.addAll(((Register)global_registers.get("eax")).spill(""));

            Tac new_entry3 = new Tac();
            String op1_reg_name = symbolTable.get(line.op1).get_prev_register();
            if(op1_reg_name!=null)
            {
              new_entry3.op2 = op1_reg_name;
            }
            else
            {
              new_entry3.op2 = "[ebp-"+ symbolTable.get_real_offset(line.op1)+"]";
            }
            
            res_register = (Register)global_registers.get("eax"); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.res);
                   
            s2.add_to_addrdesc(res_register.name,line.res);
            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s2);
            
            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map2);

            
            new_entry3.res="mov";
            new_entry3.op1=res_register.name;
            x86_array.add(new_entry3);
            

            //force op2 to go into cl
            String op2_reg_name = symbolTable.get(line.op2).get_prev_register();
            if(op2_reg_name!=null)
            {
              Tac new_entry2 = new Tac();
              new_entry2.op2 = op2_reg_name;
              new_entry2.res="mov";
              new_entry2.op1="cl";
              x86_array.add(new_entry2);
            }
            else
            {
              Tac new_entry2 = new Tac();
              new_entry2.op2 = "[ebp-"+ symbolTable.get_real_offset(line.op2)+"]";
              new_entry2.res="mov";
              new_entry2.op1="cl";
              x86_array.add(new_entry2); 
            }

            new_entry.res="shr";
            new_entry.op1=res_register.name;
            new_entry.op2="cl";
            x86_array.add(new_entry);


          }
          else if ( line.opr == "<<" )
          {
            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            x86_array.addAll(((Register)global_registers.get("eax")).spill(""));

            Tac new_entry3 = new Tac();
            String op1_reg_name = symbolTable.get(line.op1).get_prev_register();
            if(op1_reg_name!=null)
            {
              new_entry3.op2 = op1_reg_name;
            }
            else
            {
              new_entry3.op2 = "[ebp-"+ symbolTable.get_real_offset(line.op1)+"]";
            }
            
            res_register = (Register)global_registers.get("eax"); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.res);
                   
            s2.add_to_addrdesc(res_register.name,line.res);
            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s2);
            
            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map2);

            
            new_entry3.res="mov";
            new_entry3.op1=res_register.name;
            x86_array.add(new_entry3);
            

            //force op2 to go into cl
            String op2_reg_name = symbolTable.get(line.op2).get_prev_register();
            if(op2_reg_name!=null)
            {
              Tac new_entry2 = new Tac();
              new_entry2.op2 = op2_reg_name;
              new_entry2.res="mov";
              new_entry2.op1="cl";
              x86_array.add(new_entry2);
            }
            else
            {
              Tac new_entry2 = new Tac();
              new_entry2.op2 = "[ebp-"+ symbolTable.get_real_offset(line.op2)+"]";
              new_entry2.res="mov";
              new_entry2.op1="cl";
              x86_array.add(new_entry2); 
            }

            new_entry.res="shl";
            new_entry.op1=res_register.name;
            new_entry.op2="cl";
            x86_array.add(new_entry);  
          }
          else if ( line.opr == "<" )
          {
            new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+ symbolTable.get_real_offset(line.op1)+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "setb";
            x86_array.add(new_entry2);

          }
          else if ( line.opr == "<=" )
          {
            //Tac new_entry = new Tac();
              new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+ symbolTable.get_real_offset(line.op1)+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "setbe";
            x86_array.add(new_entry2);
          }
          else if ( line.opr == ">" )
          {
            //Tac new_entry = new Tac();
              new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+ symbolTable.get_real_offset(line.op1)+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "seta";
            x86_array.add(new_entry2);
          }
          else if ( line.opr == ">=" )
          {
            //Tac new_entry = new Tac();
             new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+ symbolTable.get_real_offset(line.op1)+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "setae";
            x86_array.add(new_entry2);      
          }
          else if ( line.opr == "==" )
          {
            new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+ symbolTable.get_real_offset(line.op1)+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "sete";
            x86_array.add(new_entry2);
          }
          else if ( line.opr == "!" )
          {
            //Tac new_entry = new Tac();
            x86_array.add(new_entry);
            new_entry.res = "not";
            new_entry.op1 = line.op1;        
          }
          else if ( line.opr == "!=" )
          {
            //Tac new_entry = new Tac();
              new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.updateInEnv_whereVarActuallyIs(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+ symbolTable.get_real_offset(line.op1)+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.updateInEnv_whereVarActuallyIs(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "setne";
            x86_array.add(new_entry2);      
          }
          else if ( line.opr == "&^" )
          {
            //Tac new_entry = new Tac();
            x86_array.add(new_entry);
            new_entry.res = "mov";
            new_entry.op1 = line.res;
            new_entry.op2 = line.op1;
            
            Tac new_entry2 = new Tac();
            x86_array.add(new_entry2);
            new_entry2.res = "and";
            new_entry2.op1 = line.res;
            new_entry2.op2 = line.op2; 

            Tac new_entry3 = new Tac();
            x86_array.add(new_entry3);
            new_entry3.res = "not";
            new_entry3.op1 = new_entry2.op1;
          }
          else if ( line.opr == "goto" )
          {
            // need to spill registers since we would be jumping somewhere and
            // that place would assume registers to be empty
            for(Object key : global_registers.keySet())
            {
              x86_array.addAll( ((Register)(global_registers.get((String)key))).spill(""));
              
            }
            returnValue = 1;

            if ( line.op1 == null && line.op2 == null )  
            {
               // System.out.print("LINE RECIEVED &&&&&&&&&");
              // line.print_tac();
              // System.out.print(line.res+" : "+line.op1+" : "+line.opr+" : "+line.op2);
              //Tac new_entry = new Tac();
              new_entry.res = "jmp";
              new_entry.op1= line.res.replace("<","");
              new_entry.op1 = new_entry.op1.replace(">","");
              x86_array.add(new_entry);
            }
            else
            {
              //Tac new_entry = new Tac();
              new_entry.res = "cmp";
              // new_entry.op1 = line.op1
              String[] parts = line.op1.split("false ");
              String cond_var = parts[1];
              // new_entry.op1 = 

              op1_register = getReg(cond_var,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
              SymbolTableEntry s2 = symbolTable.get(cond_var);

              s2.add_to_addrdesc(op1_register.name,cond_var);
              symbolTable.updateInEnv_whereVarActuallyIs(cond_var, s2);


              Map reg_map2 = new HashMap();//variable-> symboltable
              reg_map2.put(cond_var,symbolTable);
              op1_register.add_to_regdesc(reg_map2);

              new_entry.op2 = op1_register.name;

              new_entry.op1 =op1_register.name;
              new_entry.op2 = "0";   
              x86_array.add(new_entry);
              
              Tac new_entry2 = new Tac();
              new_entry2.res = "jle";
              new_entry2.op1= line.res.replace("<","");
              new_entry2.op1 = new_entry2.op1.replace(">","");
              // new_entry2.op1 = line.res;
             
              x86_array.add(new_entry2);
            }
          }
      }
      else if ( line.res == "ret" ) // the function is returning
      {
        returnValue = 1;
         for(Object key : global_registers.keySet())
        {
              x86_array.addAll( ((Register)(global_registers.get((String)key))).spill(""));
              
        }
        // poping out the function as it is returning
        Tac new_entry22 = new Tac();
        new_entry22.res="mov";
        new_entry22.op1="esp";
        new_entry22.op2 = "ebp";
        x86_array.add(new_entry22);

        Tac new_entry23 = new Tac();
        new_entry23.res= "pop";
        new_entry23.op1 = "ebp";
        x86_array.add(new_entry23);

        String empty_register=null;
        LinkedList<String> full_registers = new LinkedList<String>();
        for(Object tac : x86_array_deferred)
        {
            full_registers.add(((Tac)tac).op1);
        }
        for(Object key : global_registers.keySet())
        {
          if(!full_registers.contains((String)key))
          {
            empty_register = (String)key;
            break;
          }
        }
        Tac new_entry42 = new Tac();
        new_entry42.res = "pop";
        new_entry42.op1=empty_register;
        x86_array.add(new_entry42);

        x86_array.addAll(x86_array_deferred);
        x86_array_deferred.clear();

        Tac new_entry43 = new Tac();
        new_entry43.res = "push";
        new_entry43.op1=empty_register;
        x86_array.add(new_entry43);


        Tac new_entry24 = new Tac();
        new_entry24.res= "ret";
        x86_array.add(new_entry24);

      }
      else if(line.res =="call")
      {
        for(Object key : global_registers.keySet())
        {
              x86_array.addAll( ((Register)(global_registers.get((String)key))).spill(""));
              
        }
        new_entry.res="call";
        new_entry.op1 = line.op1.substring(1);
        x86_array.add(new_entry);
      }
      else if(line.res == "push")
      {
        SymbolTableEntry s = symbolTable.get(line.op1);
        String prev_reg=s.get_prev_register();
        if(prev_reg==null)
          new_entry.op1="DWORD [ebp-"+symbolTable.get_real_offset(line.op1)+"]";
        else
          new_entry.op1=prev_reg;
        new_entry.res="push";
        x86_array.add(new_entry);

      }
      else if(line.res == "push_ret")
      {
        SymbolTableEntry s = symbolTable.get(line.op1);

        String prev_reg=s.get_prev_register();
        if(prev_reg==null)
        {
          Tac new_entry42 = new Tac();
          op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
          // SymbolTableEntry s2 = symbolTable.get(line.op1);

          s.add_to_addrdesc(op1_register.name,line.op1);
          symbolTable.updateInEnv_whereVarActuallyIs(line.op1, s);


          Map reg_map2 = new HashMap();//variable-> symboltable
          reg_map2.put(line.op1,symbolTable);
          op1_register.add_to_regdesc(reg_map2);
          
          new_entry42.op1 = op1_register.name;
          new_entry42.op2 = "[ebp-"+symbolTable.get_real_offset(line.op1)+"]";
          new_entry42.res = "mov1";
          x86_array.add(new_entry42);
          prev_reg = op1_register.name;
        } 

        new_entry.res="push";
        new_entry.op1=prev_reg;
        x86_array_deferred.add(new_entry);
      }
      else if(line.res=="<get_from_stack>")
      {
        
        new_entry.res="pop DWORD";
        SymbolTableEntry s = symbolTable.get(line.op1);
        String prev_reg = s.get_prev_register();
        if(prev_reg==null)
          new_entry.op1="[ebp-"+symbolTable.get_real_offset(line.op1)+"]";
        else
          new_entry.op1=prev_reg;
        
        x86_array.add(new_entry);

      }
      else if(line.res=="<load>")
      {
        int i=8;
        for (String retval: line.op1.split(";"))
        {
              op1_register = getReg(retval,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
              SymbolTableEntry s2 = symbolTable.get(retval);

              s2.add_to_addrdesc(op1_register.name,retval);
              symbolTable.updateInEnv_whereVarActuallyIs(retval, s2);


              Map reg_map2 = new HashMap();//variable-> symboltable
              reg_map2.put(retval,symbolTable);
              op1_register.add_to_regdesc(reg_map2);
              Tac new_entry42 = new Tac();
              new_entry42.res = "mov";
              new_entry42.op1 = op1_register.name;
              new_entry42.op2 = "[ebp+"+i+"]";
              x86_array.add(new_entry42);
              i+=4;

        }
      }
      else
      {
        System.out.println("ERROR : Label sent here");
      }

      return returnValue;
    }




    public Register getReg(String variable, int mode,Env symbolTable,Tac line,LinkedList<Tac> x86_array)//mode =0 for left, mode=1 for right
    {
      if(mode==0)
      {
        SymbolTableEntry s = symbolTable.get(variable);
        if( s.addressDescriptor.size()!=0 )
        {
          String reg = s.get_prev_register();
          if(reg!=null)
          {
            Register retrieved_register = (Register)(global_registers.get(reg));
            if(retrieved_register.if_var_in_reg(variable)==true)
            {
              //now we spill back other variables as we are changing reg value.
              x86_array.addAll(retrieved_register.spill(variable));
              return retrieved_register;
            }
            
            else
            {
                System.out.println("ERROR: Mismatch in addressDescriptor and regDescriptor");
            }
          }
          else//need to kick out or find an empty register
          {
              for ( Object key : global_registers.keySet() ) 
              {
                  Register temp_reg =  (Register)(global_registers.get((String)key));
                  if(temp_reg.is_descriptor_empty()==true)
                    return temp_reg;
              }
              System.out.println("KICCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCKKKKKKKKKKING MODE 0");
              //Oh no! someone is gonna lose registers
              //finding least spill cost among registers
              int min_cost=1000000;
              int cur_cost=1000000;
              String min_key="";
              for ( Object key : global_registers.keySet() ) 
              {
                  Register temp_reg =  (Register)(global_registers.get((String)key));
                  // if(temp_reg.is_descriptor_empty()==true)
                    // return temp_reg;
                  cur_cost=temp_reg.spill_cost(line);
                  if(cur_cost<min_cost)
                  {
                    min_key = (String)key;
                    min_cost = cur_cost; 
                  }
              }
              Register selectedReg = (Register) global_registers.get(min_key);
              x86_array.addAll(selectedReg.spill(variable));
              return selectedReg;
          }
        }
        else
        {
            for ( Object key : global_registers.keySet() ) 
            {
                Register temp_reg =  (Register)(global_registers.get((String)key));
                if(temp_reg.is_descriptor_empty()==true)
                  return temp_reg;
            }
              System.out.println("KICCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCKKKKKKKKKKING NASTY MODE 0");

            //Oh no! someone is gonna lose registers
            //finding least spill cost among registers
            int min_cost=1000000;
            int cur_cost=1000000;
            String min_key="";
            for ( Object key : global_registers.keySet() ) 
            {
                Register temp_reg =  (Register)(global_registers.get((String)key));
                // if(temp_reg.is_descriptor_empty()==true)
                  // return temp_reg;
                cur_cost=temp_reg.spill_cost(line);
                System.out.println("Searching space for "+variable+ "  "+"REG: "+temp_reg.name+" spill cost "+cur_cost);
                if(cur_cost<min_cost)
                {
                  min_key = (String)key;
                  min_cost = cur_cost; 
                }
            }
            Register selectedReg = (Register)(global_registers.get(min_key));
            x86_array.addAll(selectedReg.spill(variable));
            return selectedReg;
        }
      }
      else if(mode==1)
      {
        SymbolTableEntry s = symbolTable.get(variable);
        if(s==null)
          return null;//for constants
        
        if( s.addressDescriptor.size()!=0 )
        {
          String reg = s.get_prev_register();
          if(reg!=null)
          {
            Register retrieved_register = (Register)(global_registers.get(reg));
            if(retrieved_register.if_var_in_reg(variable)==true)
              return retrieved_register;
            else
            {
                System.out.println("ERROR: Mismatch in addressDescriptor and regDescriptor");
            }
          }
          else//need to kick out or find an empty register
          {
              for ( Object key : global_registers.keySet() ) 
              {
                  Register temp_reg =  (Register)(global_registers.get((String)key));
                  if(temp_reg.is_descriptor_empty()==true)
                  { 
                      if(s.is_empty_addrDesc()==true)
                      {
                        return temp_reg;
                      }
                      Tac new_entry = new Tac();
                      new_entry.res="mov";
                      new_entry.op1=temp_reg.name;
                      new_entry.op2=s.addressDescriptor.getFirst();
                      x86_array.add(new_entry);
                      return temp_reg;
                  }
              }
              System.out.println("KICCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCKKKKKKKKKKING  MODE 1");

              //Oh no! someone is gonna lose registers
              //finding least spill cost among registers
              int min_cost=1000000;
              int cur_cost=1000000;
              String min_key="";
              for ( Object key : global_registers.keySet() ) 
              {
                  Register temp_reg =  (Register)(global_registers.get((String)key));
                  // if(temp_reg.is_descriptor_empty()==true)
                    // return temp_reg;
                  cur_cost=temp_reg.spill_cost(line);
                  System.out.println("[mode 1] Searching space for "+variable+ "  "+"REG: "+temp_reg.name+" spill cost "+cur_cost);
                  if(cur_cost<min_cost)
                  {
                    min_key = (String)key;
                    min_cost = cur_cost; 
                  }
              }
              Register selectedReg = (Register) global_registers.get(min_key);
              x86_array.addAll(selectedReg.spill(variable));
              
              if(s.is_empty_addrDesc()==true)
              {
                return selectedReg;
              }
              Tac new_entry = new Tac();
              new_entry.res="mov";
              new_entry.op1=selectedReg.name;
              new_entry.op2=s.addressDescriptor.getFirst();
              x86_array.add(new_entry);
              return selectedReg;
          }
        }
        else
        {
            for ( Object key : global_registers.keySet() ) 
            {
                Register temp_reg =  (Register)(global_registers.get((String)key));
                if(temp_reg.is_descriptor_empty()==true)
                  return temp_reg;
            }
              System.out.println("KICCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCKKKKKKKKKKING NASTY MODE 1");

            //Oh no! someone is gonna lose registers
            //finding least spill cost among registers
            int min_cost=1000000;
            int cur_cost=1000000;
            String min_key="";
            for ( Object key : global_registers.keySet() ) 
            {
                Register temp_reg =  (Register)(global_registers.get((String)key));
                // if(temp_reg.is_descriptor_empty()==true)
                  // return temp_reg;
                cur_cost=temp_reg.spill_cost(line);
                if(cur_cost<min_cost)
                {
                  min_key = (String)key;
                  min_cost = cur_cost; 
                }
            }
            Register selectedReg = (Register)(global_registers.get(min_key));
            x86_array.addAll(selectedReg.spill(variable));
            return selectedReg;
        }
      }
      else
      {
        System.out.println("ERROR: ARE YAAR mode is <> 0 or 1 !");
      }
      return null;
    }



/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= SourceFile EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // Type ::= TypeName 
            {
              GoType RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoTypeName t = (GoTypeName)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoType(t); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Type",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // Type ::= TypeLit 
            {
              GoType RESULT =null;
		int tlleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tlright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoTypeLit tl = (GoTypeLit)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = new GoType(tl);
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Type",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // Type ::= open_brac Type close_brac 
            {
              GoType RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoType t = (GoType)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = t; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Type",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // TypeName ::= B 
            {
              GoTypeName RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                RESULT = new GoTypeName(b); 
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TypeName",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // TypeName ::= C 
            {
              GoTypeName RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                RESULT = new GoTypeName(c); 
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TypeName",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // B ::= C dot identifier 
            {
              String RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = c+"."+i; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("B",206, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // C ::= identifier 
            {
              String RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = i; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("C",207, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // TypeLit ::= ArrayType 
            {
              GoTypeLit RESULT =null;
		int atleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int atright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoArrayType at = (GoArrayType)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoTypeLit(at); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TypeLit",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // TypeLit ::= PointerType 
            {
              GoTypeLit RESULT =null;
		int ptleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ptright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoPointerType pt = (GoPointerType)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoTypeLit(pt); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TypeLit",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // TypeLit ::= FunctionType 
            {
              GoTypeLit RESULT =null;
		int ftleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ftright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoSignature ft = (GoSignature)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoTypeLit(ft); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TypeLit",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ArrayType ::= open_square_brac ArrayLength close_square_brac Type 
            {
              GoArrayType RESULT =null;
		int alleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int alright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Integer al = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoType t = (GoType)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoArrayType(al, t); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ArrayType",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ArrayLength ::= int_lit 
            {
              Integer RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT =  new Integer(Integer.parseInt( i )); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ArrayLength",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // PointerType ::= star_op Type 
            {
              GoPointerType RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoType t = (GoType)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoPointerType(t); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PointerType",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // Func_call ::= TypeName open_brac close_brac 
            {
              GoFunc_call RESULT =null;
		int tnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int tnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoTypeName tn = (GoTypeName)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 
                if(top.get("_"+tn.typeName)!=null)
                {
                  Tac new_entry = new Tac();
                  new_entry.res = "call";
                  new_entry.op1 = "_"+tn.typeName;
                  quad_array.add(new_entry);

                      

                }
                else
                {
                  System.out.println("ERROR: Function not defined");
                } 
                RESULT = new GoFunc_call( tn );
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Func_call",208, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // Func_call ::= TypeName open_brac ExpressionList close_brac 
            {
              GoFunc_call RESULT =null;
		int tnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int tnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		GoTypeName tn = (GoTypeName)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int elleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		LinkedList<GoExpr> el = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                 if(top.get("_"+tn.typeName)==null)
                    System.out.println("ERROR: Function "+tn.typeName+" not defined");
                  else
                  {

                      String[] allowed_expected_types = new String[]{"bool","byte","complex64","complex128","float32","float64","int","int8","int16","int32","int64","rune","string","uint","uint8","uint16","uint32","uint64","uintpt"};
                      // System.out.println("GOOD NEWs:  FUnction call working");
                      // LinkedList<GoExpr> expr = (LinkedList<GoExpr>)s1.get("func_ass");
                      // expr.addFirst(e);
                      String func_name = "_"+tn.typeName;
                      SymbolTableEntry func_entry = top.get(func_name);
                      // if(func_entry !=null )
                      // {
                      GoSignature func_sig = (GoSignature)(func_entry.dataType);
                      // if(func_sig.obj instanceof LinkedList)//multiple return types
                      // {
                      int k=0;
                      LinkedList<GoParameterDecl> parameters =func_sig.parameters;
                      int expected_number = 0;
                      for(int q=0;q<parameters.size();++q)
                      {
                        if(parameters.get(q).identifierList!=null)
                            expected_number+=parameters.get(q).identifierList.size();
                        else
                          expected_number++;
                      }
                      if(expected_number!=el.size())
                        System.out.println("ERROR: Unequal number of parameters."+expected_number+" != "+el.size());
                      
                      // System.out.println("PARAMETER SIZE:"+parameters.size());
                      for(int i=0;i<parameters.size();++i)
                      {
                        // System.out.println("Checking param types");
                        GoParameterDecl params= parameters.get(i);
                        if(params.identifierList!=null)
                        {
                          for(int j=0;j<params.identifierList.size();++j)
                          {
                            if(k==el.size())
                            {
                              System.out.println("ERROR: Too many variables expected from functions");
                              break;
                            }
                            SymbolTableEntry s100 =new SymbolTableEntry(params.type.obj,false,0);

                            String expr_type = el.get(k).get_type();
                            if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                              expr_type = top.get(expr_type).parsedDataType;
                            if(!expr_type.equals(s100.parsedDataType))
                            {
                             System.out.println("expected : "+expr_type +" Found : "+s100.parsedDataType);
                             System.out.println("ERROR: Type Mismatch in func call");
                            }
                                                           
                            k++;

                          }

                        }
                        else
                        {
                          if(k==el.size())
                          {
                            System.out.println("ERROR: Too many variables expected from functions");
                            break;
                          }
                          SymbolTableEntry s100 =new SymbolTableEntry(params.type.obj,false,0);
                          String expr_type = el.get(k).get_type();
                          if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                            expr_type = top.get(expr_type).parsedDataType;
                          if(!expr_type.equals(s100.parsedDataType))
                          {
                           System.out.println("expected :"+ expr_type +" Found : "+s100.parsedDataType);
                           System.out.println("ERROR: Type Mismatch in calling function");
                          }
                         
                          Tac new_entry2 =new Tac();
                        
                          k++;

                        }
                      }
                      // }

                    




                      for(int i=0;i<el.size();++i)
                      {
                          Tac new_entry = new Tac();
                          new_entry.res = "push";
                          new_entry.op1 =  quad_array.get(el.get(i).index).res;
                          quad_array.add(new_entry);
                      /**/
                      }
                      Tac new_entry2 = new Tac();
                      new_entry2.res = "call";
                      new_entry2.op1 = "_"+tn.typeName;
                      quad_array.add(new_entry2);
                  }
                
                

                  RESULT = new GoFunc_call( tn, el );
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Func_call",208, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // FunctionType ::= funcd Signature 
            {
              GoSignature RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoSignature s = (GoSignature)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = s;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FunctionType",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // Signature ::= Parameters Parameters 
            {
              GoSignature RESULT =null;
		int p1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int p1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		LinkedList<GoParameterDecl> p1 = (LinkedList<GoParameterDecl>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int p2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int p2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoParameterDecl> p2 = (LinkedList<GoParameterDecl>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoSignature(p1,p2); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Signature",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // Signature ::= Parameters Type 
            {
              GoSignature RESULT =null;
		int p1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int p1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		LinkedList<GoParameterDecl> p1 = (LinkedList<GoParameterDecl>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoType t = (GoType)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoSignature(p1,t); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Signature",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // Signature ::= Parameters 
            {
              GoSignature RESULT =null;
		int p1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int p1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoParameterDecl> p1 = (LinkedList<GoParameterDecl>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoSignature(p1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Signature",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // Parameters ::= open_brac ParameterList close_brac 
            {
              LinkedList<GoParameterDecl> RESULT =null;
		int plleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int plright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		LinkedList<GoParameterDecl> pl = (LinkedList<GoParameterDecl>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT= pl; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Parameters",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // Parameters ::= open_brac close_brac 
            {
              LinkedList<GoParameterDecl> RESULT =null;
		 RESULT= new LinkedList<GoParameterDecl>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Parameters",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // ParameterList ::= ParameterDecl ParameterList_unnecessary_1 
            {
              LinkedList<GoParameterDecl> RESULT =null;
		int pdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int pdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoParameterDecl pd = (GoParameterDecl)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int plleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int plright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoParameterDecl> pl = (LinkedList<GoParameterDecl>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 pl.addFirst(pd); RESULT = pl; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ParameterList",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ParameterList_unnecessary_1 ::= ParameterList_unnecessary_1 comma ParameterDecl 
            {
              LinkedList<GoParameterDecl> RESULT =null;
		int pl1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int pl1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		LinkedList<GoParameterDecl> pl1 = (LinkedList<GoParameterDecl>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int pdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoParameterDecl pd = (GoParameterDecl)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 pl1.add(pd); RESULT = pl1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ParameterList_unnecessary_1",130, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // ParameterList_unnecessary_1 ::= 
            {
              LinkedList<GoParameterDecl> RESULT =null;
		 RESULT = new LinkedList<GoParameterDecl>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ParameterList_unnecessary_1",130, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // ParameterDecl ::= IdentifierList Type 
            {
              GoParameterDecl RESULT =null;
		int i1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int i1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		LinkedList<String> i1 = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoType t = (GoType)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoParameterDecl(i1, t); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ParameterDecl",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // ParameterDecl ::= Type 
            {
              GoParameterDecl RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoType t = (GoType)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoParameterDecl(t); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ParameterDecl",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // NT$0 ::= 
            {
              Object RESULT =null;
 if(top!=null) 
              {
                top = new Env(top,next_env_name(0));

                Tac new_entry = new Tac();
                new_entry.res = next_label()+":";
                new_entry.opr = top.get_name();
                quad_array.add(new_entry);

                // System.out.println("NEW BLOCK TABLE"); 
              } 
          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$0",212, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // Block ::= open_curly_brac NT$0 StatementList close_curly_brac 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 
            // print_sym_table();
            if(top.get_prev()!=null)
              top = top.get_prev();

            Tac new_entry = new Tac();
            new_entry.res = next_label()+":";
            new_entry.opr = top.get_name();
            quad_array.add(new_entry);
                
          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Block",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // StatementList ::= StatementList_unnecessary_1 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("StatementList",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // StatementList_unnecessary_1 ::= StatementList_unnecessary_1 Statement semicolon 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("StatementList_unnecessary_1",135, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // StatementList_unnecessary_1 ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("StatementList_unnecessary_1",135, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // TopLevelDecl ::= FunctionDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TopLevelDecl",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // TopLevelDecl ::= Declaration 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TopLevelDecl",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // NT$1 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

                  /**/
                  //problem how to know whether prototype or real function, so using the standard method
                  Tac new_entry = new Tac();
                  new_entry.res = "_"+i+":";
                  new_entry.opr = next_env_name(0);

                  quad_array.add(new_entry);

                  SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1,i);
                  top.put("func<>",s);//for manipulating the label created above

                 s = new SymbolTableEntry();
                  top.put("_"+i,s); //prototype also gets to go to the symbol table but it's label 3AC is removed 
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$1",213, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // FunctionDecl ::= funcd identifier NT$1 FunctionDecl_unnecessary_1 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int funleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int funright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoSignature fun = (GoSignature)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		

                  SymbolTableEntry s = new SymbolTableEntry(fun,true,0);
                  // System.out.println("WHILE UPDATING  PARAMETERS ARE:"+((GoSignature)(s.dataType)).parameters.size());
                  top.update("_"+i,s);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FunctionDecl",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // FunctionDecl_unnecessary_1 ::= Function 
            {
              GoSignature RESULT =null;
		int fsigleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fsigright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoSignature fsig = (GoSignature)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		/**/
                                    Tac new_entry = new Tac();
                                    new_entry.res = "ret";
                                    quad_array.add(new_entry);
                                    // System.out.println("WHILE UPDATING  REICEVED PARAMETERS ARE2:"+fsig.parameters.size());

                                    top.removeFromCurrent("func<>");
                                    RESULT = fsig;
                                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FunctionDecl_unnecessary_1",148, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // FunctionDecl_unnecessary_1 ::= Signature 
            {
              GoSignature RESULT =null;
		int sileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int siright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoSignature si = (GoSignature)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		  /**/
                                     SymbolTableEntry s = top.get("func<>");
                                     quad_array.remove(s.size);
                                     top.removeFromCurrent("func<>");
                                     // s = new SymbolTableEntry ()
                                      // System.out.println("WHILE UPDATING  REICEVED PARAMETERS ARE1:"+si.parameters.size());

                                     RESULT = si;
                                     //removed label for function protoype 
                                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FunctionDecl_unnecessary_1",148, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // NT$2 ::= 
            {
              GoSignature RESULT =null;
		int sileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int siright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoSignature si = (GoSignature)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

                    top = new Env(top,true,next_env_name(1)); 
                      

                    for(int i=0;i<si.parameters.size();++i)
                    {

                      if(si.parameters.get(i).identifierList!=null)
                      {
                        Tac new_entry =new Tac();
                        new_entry.res="<load>";
                        for(int j=0;j<si.parameters.get(i).identifierList.size();++j)
                        {
                          if(j==0)
                            new_entry.op1=si.parameters.get(i).identifierList.get(j);
                          else
                            new_entry.op1=si.parameters.get(i).identifierList.get(j)+";"+new_entry.op1;
                        }
                        quad_array.add(new_entry);
                      }
                    }


                    // String id;
                    

                    // System.out.println("WHILE UPDATING  REICEVED PARAMETERS ARE3:"+String.valueOf (si.parameters.size()));
                    // System.out.println("NEW TABLE IN FUnction");
                    SymbolTableEntry s;
                    for(int i=0;i<si.parameters.size();++i)
                    {
                      // System.out.println("Hello bellow2");
                      GoParameterDecl paramDecl =  si.parameters.get(i);
                      for (int j=0;j<paramDecl.identifierList.size() ; ++j) 
                      {
                        s = new SymbolTableEntry( paramDecl.type.obj,false,top.global_offset );  
                        top.global_offset+=s.size;
                        top.put( paramDecl.identifierList.get(j),s );  

                        // Tac new_entry2 = new Tac();
                        // id =  paramDecl.identifierList.get(j);

                        // new_entry2.op1 = "#"+id+"#";
                        // new_entry2.res ="<get_from_stack>";
                        // // new_entry2.opr= "=" ;
                        
                        // quad_array.add(new_entry2);

                      }

                    }
                    if(si.obj instanceof GoType)
                    {
                      // System.out.println("Hello bellow1");
                      GoType return_type = (GoType)si.obj;
                      // s = new SymbolTableEntry( return_type.obj,false );
                      s = new SymbolTableEntry( return_type.obj,false,top.global_offset );
                      top.global_offset+=s.size;

                      top.put("return[0]",s );  
                    }
                    else if (si.obj instanceof LinkedList)
                    {
                      // SymbolTableEntry s[si.obj.size()];
                      // System.out.println("Hello bellow");
                      LinkedList<GoParameterDecl> temp_obj = (LinkedList<GoParameterDecl>)si.obj;
                      int k=0;
                      for(int i=0;i<temp_obj.size();++i)
                      {
                          // s = new SymbolTableEntry( temp_obj.get(i).type.obj,false );
                      /**/    
                        if(temp_obj.get(i).identifierList!=null)
                        {
                          for(int j=0;j<temp_obj.get(i).identifierList.size();++j)
                          {
                            s = new SymbolTableEntry(temp_obj.get(i).type.obj,false,top.global_offset );
                            top.put("return["+k+"]",s );
                            k++;
                            s = new SymbolTableEntry(temp_obj.get(i).type.obj,false,top.global_offset);
                            top.global_offset+=s.size;
                            top.put(temp_obj.get(i).identifierList.get(j),s);
                          }
                        }
                        else
                        {
                          s = new SymbolTableEntry(temp_obj.get(i).type.obj,false,top.global_offset );
                          // top.global_offset+=s.size;
                          top.put("return["+k+"]",s );

                          k++;
                        }
                          //TODO-DONE add support for identifierlist in symboltable
                      }

                    }
                    RESULT =si;
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$2",214, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // Function ::= Signature NT$2 FunctionBody 
            {
              GoSignature RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (GoSignature) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int sileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int siright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoSignature si = (GoSignature)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int fbleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fbright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object fb = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                      // print_sym_table();
                      if(si.obj!=null  )
                      {
                          if(si.obj instanceof LinkedList)
                          {
                            if(((LinkedList<GoParameterDecl>)si.obj).size()!=0 && top.getQuiet("@return@")==null)
                              System.out.println("ERROR: Missing return statement in function");
                          }
                          else
                          {
                           if(top.getQuiet("@return@")==null)
                              System.out.println("ERROR: Missing return statement in function");
                          }

                      }
                     /* if(top.getQuiet("@return@")==null)
                      {
                        //must be void function else error
                        if(si.obj ==null)
                        {
                          System.out.println("ERROR: Missing return statement in function");
                        }
                      }*/
                      if(top.get_prev()!=null)
                        top = top.get_prev(); 
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Function",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // FunctionBody ::= open_curly_brac StatementList close_curly_brac 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FunctionBody",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // Declaration ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Declaration",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // Declaration ::= VarDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Declaration",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // ConstDecl ::= constd ConstDecl_unnecessary_2 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDecl",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // ConstDecl_unnecessary_1 ::= ConstDecl_unnecessary_1 ConstSpec semicolon 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDecl_unnecessary_1",136, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // ConstDecl_unnecessary_1 ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDecl_unnecessary_1",136, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // ConstDecl_unnecessary_2 ::= ConstSpec 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDecl_unnecessary_2",137, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // ConstDecl_unnecessary_2 ::= open_brac ConstDecl_unnecessary_1 close_brac 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDecl_unnecessary_2",137, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // ConstSpec ::= IdentifierList Type equal ExpressionList 
            {
              Object RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		LinkedList<String> il = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoType t = (GoType)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int elleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoExpr> el = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                      // System.out.println("Adding constant to symbol table");
                      // LinkedList<GoExpr> expList = (LinkedList<GoExpr>).get("ExpressionList");
                      SymbolTableEntry s;
                      boolean flag = true;
                      if ( il.size() != el.size() )
                      {
                          if( el.size() > 0 )
                          {
                            if ( el.size() > il.size() )
                            {
                              System.out.println("ERROR: extra expression in const declaration");
                            }
                            else
                            {
                              System.out.println("ERROR: missing value in const declaration");
                            }
                          }
                          flag = false;
                      }
                      // System.out.println("Size of id is "+il.size()+" size of el is "+el.size());
                      String dataType_from_id = t.get_type();

                      dataType_from_id = get_type_from_symboltable(dataType_from_id);

                      for ( int i = 0; i < il.size(); i++ ) 
                      {
                          if ( flag == true )
                          {
                              // typechecking
                              // System.out.println("Inside flag true");
                              
                              String dataType_from_exp = el.get(i).get_type(); // now this type can be either a real datatype like int32, int etc or can be the name of the identifier 
                              // so if it is the name of an identifier, we will look at its symbol table entry and derive its parsedDataType from there
                              
                              dataType_from_exp = get_type_from_symboltable(dataType_from_exp);

                              SymbolTableEntry sym = top.get(dataType_from_exp);
                              if ( sym != null )  // dataType_from_exp is identifier
                              {
                                dataType_from_exp = sym.parsedDataType;
                                // System.out.println("dataType_from_exp changed to "+dataType_from_exp);
                              }

                              // System.out.println("vu is "+dataType_from_vu+" exp is "+dataType_from_exp);


                              if ( dataType_from_id.equals(dataType_from_exp) == false )
                              {
                                if ( el.get(i).get_identifier() != null )
                                  System.out.println("ERROR: cannot use "+el.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_id+" in assignment 1");
                                else
                                  System.out.println("ERROR: cannot use "+"(type "+dataType_from_exp+") as type "+dataType_from_id+" in assignment 2");
                              }
                              else
                              {
                                // System.out.println("CORRECT: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment");
                              }

                              s = new SymbolTableEntry(  t.obj, true, top.global_offset);    // expressionlist also needs to be handled
                              Tac new_entry = new Tac();
                                  // new_entry.res =  "Mem<"+ top.global_offset +">";
                                  new_entry.res = "#"+il.get(i)+"#";

                                  new_entry.opr = "=";
                                  new_entry.op1= quad_array.get(el.get(i).index).res;

                                  quad_array.add(new_entry);
                              top.global_offset+=s.size;
                          }
                          else
                          {
                              // System.out.println("Inside flag false");  
                              // we will never reach here as it is outside grammar rules

                              s = new SymbolTableEntry( t.obj,true, top.global_offset);
                              top.global_offset+=s.size;
                          }

                          // according to grammar, we cannot have const arrays const are like
                          // #define of C. so they cannot have arrays, maps, slices etc.

                          //for entering array 
                          if( t.obj instanceof GoTypeLit 
                              && ((GoTypeLit)t.obj).obj instanceof GoArrayType)
                          {
                            System.out.println("ERROR: arrays not allowed in const");
                            GoArrayType arr = ((GoArrayType)((GoTypeLit)t.obj).obj) ;
                            int array_size = ((Integer)(arr.arrayLength)).intValue();
                            top.global_offset-=s.size;//above statement added size of one var already to offset
                            s.size=array_size*s.size;
                            top.global_offset+=s.size;
                          }
                          top.put(il.get(i), s); 
                           
                      }
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstSpec",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // IdentifierList ::= identifier IdentifierList_unnecessary_1 
            {
              LinkedList<String> RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int i1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int i1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<String> i1 = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 i1.addFirst(i); RESULT = i1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IdentifierList",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // IdentifierList_unnecessary_1 ::= comma identifier IdentifierList_unnecessary_1 
            {
              LinkedList<String> RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int i1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int i1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<String> i1 = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 i1.addFirst(i); RESULT = i1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IdentifierList_unnecessary_1",140, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // IdentifierList_unnecessary_1 ::= 
            {
              LinkedList<String> RESULT =null;
		 RESULT = new LinkedList<String>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IdentifierList_unnecessary_1",140, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // ExpressionList ::= Expression ExpressionList_unnecessary_1 
            {
              LinkedList<GoExpr> RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int euleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int euright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoExpr> eu = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 eu.addFirst(ex); RESULT = eu; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExpressionList",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // ExpressionList_unnecessary_1 ::= ExpressionList_unnecessary_1 comma Expression 
            {
              LinkedList<GoExpr> RESULT =null;
		int euleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int euright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		LinkedList<GoExpr> eu = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 eu.add(ex); RESULT = eu; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExpressionList_unnecessary_1",141, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // ExpressionList_unnecessary_1 ::= 
            {
              LinkedList<GoExpr> RESULT =null;
		 RESULT = new LinkedList<GoExpr>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExpressionList_unnecessary_1",141, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // VarDecl ::= var VarDecl_unnecessary_2 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDecl",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // VarDecl_unnecessary_1 ::= VarDecl_unnecessary_1 VarSpec semicolon 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDecl_unnecessary_1",144, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // VarDecl_unnecessary_1 ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDecl_unnecessary_1",144, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // VarDecl_unnecessary_2 ::= VarSpec 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDecl_unnecessary_2",145, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // VarDecl_unnecessary_2 ::= open_brac VarDecl_unnecessary_1 close_brac 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDecl_unnecessary_2",145, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // VarSpec ::= IdentifierList VarSpec_unnecessary_2 
            {
              Object RESULT =null;
		int i1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int i1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		LinkedList<String> i1 = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vuleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vuright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Map vu = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    LinkedList<GoExpr> expList = (LinkedList<GoExpr>)vu.get("ExpressionList");
                    SymbolTableEntry s;
                    boolean flag = true;
                    if ( i1.size() != expList.size() )
                    {
                        if(expList.size()>0)
                        {
                          if ( expList.size() > i1.size() )
                          {
                            System.out.println("ERROR: extra expression in var declaration");
                          }
                          else
                          {
                            System.out.println("ERROR: missing expression in var declaration");
                          }
                        }
                        flag = false;
                    }

                    for ( int i = 0; i < i1.size(); i++ ) 
                    {
                        if ( flag == true ) //a ,b,c int=2,2,3;
                        {
                          if(vu.get("Type")!=null)
                          {
                                // for type checking, we need to see that dataType of vu.get("Type") is same as explist.get(i).get_type()
                                
                                String dataType_from_vu = ( (GoType)vu.get("Type") ).get_type();

                                dataType_from_vu = get_type_from_symboltable(dataType_from_vu);

                                String dataType_from_exp = expList.get(i).get_type(); // now this type can be either a real datatype like int32, int etc or can be the name of the identifier 
                                // so if it is the name of an identifier, we will look at its symbol table entry and derive its parsedDataType from there
                                
                                dataType_from_exp = get_type_from_symboltable(dataType_from_exp);

                                SymbolTableEntry sym = top.getQuiet(dataType_from_exp);
                                if ( sym != null )  // dataType_from_exp is identifier
                                {
                                  dataType_from_exp = sym.parsedDataType;
                                  // System.out.println("dataType_from_exp changed to "+dataType_from_exp);
                                }

                                // System.out.println("vu is "+dataType_from_vu+" exp is "+dataType_from_exp);

                                if ( dataType_from_vu.equals(dataType_from_exp) == false )
                                {
                                  if ( expList.get(i).get_identifier() != null )
                                    System.out.println("ERROR: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment 3");
                                  else
                                    System.out.println("ERROR: cannot use "+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment 4");
                                }
                                else
                                {
                                  // System.out.println("CORRECT: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment");
                                }

                                // System.out.println("i wrr= "+i); 
                                s = new SymbolTableEntry(  ((GoType) vu.get("Type")).obj,false,top.global_offset);    // expressionlist also needs to be handled
                                Tac new_entry = new Tac();
                                    // new_entry.res =  "Mem<"+ top.global_offset +">";
                                    new_entry.res = "#"+i1.get(i)+"#";
                                    new_entry.opr = "=";
                                    new_entry.op1= quad_array.get(expList.get(i).index).res;
                                top.global_offset+=s.size;
                                quad_array.add(new_entry);
                          }
                          else // array type of form: var a = [2]int{1,2}
                          {
                                GoUnaryExpr first_unary = expList.get(expList.size()-i-1).unaryExpr;
                                GoTypeName temp_name = new GoTypeName(first_unary.get_type());

                                // temp_name = get_type_from_symboltable(temp_name);

                                GoOperand temp_operand = (GoOperand)((GoPrimaryExpr)(first_unary.obj)).obj1;
                                GoArrayType arraytype = (GoArrayType)(temp_operand.obj);

                                String dataType_from_array = arraytype.get_type();

                                dataType_from_array = get_type_from_symboltable(dataType_from_array);

                                //FOR 1D
                                int arr_length = arraytype.get_array_length();


                                s = new SymbolTableEntry( temp_name,false, top.global_offset); //MINING TYPE_NAME FROM Expr List for array type
                                s.isArray = true;

                                LinkedList<GoElement> temp_element_list = temp_operand.litVal.eleList.eleList;
                                 int qindex = -1;
                                for(int k = 0; k < temp_element_list.size(); ++k )
                                {
                                    qindex = ((GoExpr)(temp_element_list.get(k).val.obj)).index;
                                    // quad_array.get(qindex).res; // actaul value of arr[k] !

                                    GoExpr expr = ((GoExpr)(temp_element_list.get(k).val.obj));
                                    String dataType_from_exp = expr.get_type(); // now this type can be either a real datatype like int32, int etc or can be the name of the identifier 
                                    // so if it is the name of an identifier, we will look at its symbol table entry and derive its parsedDataType from there
                                    
                                    dataType_from_exp = get_type_from_symboltable(dataType_from_exp);

                                    SymbolTableEntry sym = top.getQuiet(dataType_from_exp);
                                    if ( sym != null )  // dataType_from_exp is identifier
                                    {
                                      dataType_from_exp = sym.parsedDataType;
                                      // System.out.println("dataType_from_exp changed to "+dataType_from_exp);
                                    }



                                    if ( dataType_from_array.equals(dataType_from_exp) == false )
                                    {
                                      System.out.println("ERROR: cannot use "+expr.get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_array+" in assignment 5");
                                    }

                                    // for typechecking, we have to see that type of expr is same as type of array

                                    Tac new_entry = new Tac();
                                        // new_entry.res =  "Mem<"+ top.global_offset +">";
                                        new_entry.res = "#"+i1.get(i)+"#";
                                        new_entry.opr = "=";
                                        new_entry.op1= quad_array.get(qindex).res;
                                    top.global_offset+=s.size;
                                    quad_array.add(new_entry);
                                }

                                if ( temp_element_list.size() > arr_length )  // like var a = [2]int{1,2,3} ie more things inside array than allowed
                                {
                                  System.out.println("ERROR: "+"array index "+arr_length+" out of bounds [0:"+arr_length+"]");
                                }

                                if ( arr_length > temp_element_list.size() )  // have to initialize the remaining values with default values
                                {
                                  for(int k = 0; k < arr_length-temp_element_list.size(); ++k )
                                  {
                                    Tac new_entry = new Tac();
                                        // new_entry.res = "Mem<"+ top.global_offset +">";
                                        new_entry.res = "#"+i1.get(i)+"#";
                                        new_entry.opr = "=";
                                        new_entry.op1= s.get_default_value(s.parsedDataType);

                                    top.global_offset+=s.size;
                                    quad_array.add(new_entry);
                                  }
                                }
                                s.size=arr_length*s.size;

                                // break;
                          }

                        // top.put(i1.get(i), s); // commented since already doing it below

                        }
                        else //int uninitialized
                        {
                            // no need of typechecking here as we are only giving it default values
                            s = new SymbolTableEntry(((GoType) vu.get("Type")).obj,false, top.global_offset);
                            //TODO handle 3ac of default initialisation
                            // System.out.println("Creating "+s.offset);
                            Tac new_entry = new Tac();
                                // new_entry.res =  "Mem<"+ top.global_offset +">";
                                new_entry.res = "#"+i1.get(i)+"#";
                                new_entry.opr = "=";
                                new_entry.op1= s.get_default_value(s.parsedDataType);

                            top.global_offset+=s.size;

                            quad_array.add(new_entry);
                            // System.out.println("PUURITN "+s.offset);
                         // System.out.println("Getting "+top.get(i1.get(i)).offset);
                        }

                        if(s==null) System.out.println("ERROR: null SymbolTableEntry");
                        if(i1.get(i) == null)
                           System.out.println("ERROR: null IdentifierList");
                        
                        if(vu.get("Type") == null)
                        {
                          //YEY!!Already DOne for initialised array above
                        }
                        //for  uninitialized arrays a[16]
                        else if( ((GoType)vu.get("Type")).obj instanceof GoTypeLit && ((GoTypeLit)((GoType)vu.get("Type")).obj).obj instanceof GoArrayType)
                        {

                            // no need of type checking as we are filling default values ourselves
                            GoArrayType arr =  (GoArrayType)(((GoTypeLit)((GoType)vu.get("Type")).obj).obj);
                            int array_size = ((Integer)arr.arrayLength).intValue();
                            // top.global_offset-=s.size;//above statement added size of one var already to offset
                            // System.out.println("ARRAY SIZE "+array_size);
                            // System.out.println("S SIZE "+s.size);
                            for(int q=1;q<array_size;++q)
                            {
                                Tac new_entry = new Tac();
                                // new_entry.res = "Mem<"+ top.global_offset +">";
                                new_entry.res = "#"+i1.get(i)+"#";
                                new_entry.opr = "=";
                                new_entry.op1= s.get_default_value(s.parsedDataType);

                                top.global_offset+=s.size;
                                quad_array.add(new_entry);
                            }
                            s.size=array_size*s.size;
                            s.isArray = true;
                            // top.global_offset+=s.size;

                        }
                    top.put(i1.get(i), s);
                    }

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarSpec",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // VarSpec_unnecessary_1 ::= equal ExpressionList 
            {
              LinkedList<GoExpr> RESULT =null;
		int elleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoExpr> el = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = el; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarSpec_unnecessary_1",146, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // VarSpec_unnecessary_1 ::= 
            {
              LinkedList<GoExpr> RESULT =null;
		 RESULT = new LinkedList<GoExpr>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarSpec_unnecessary_1",146, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // VarSpec_unnecessary_2 ::= Type VarSpec_unnecessary_1 
            {
              Map RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoType t = (GoType)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vuleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vuright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoExpr> vu = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                                Map a = new HashMap(); 
                                a.put("Type", t); 
                                a.put("ExpressionList", vu);
                                RESULT = a; 
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarSpec_unnecessary_2",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // VarSpec_unnecessary_2 ::= equal ExpressionList 
            {
              Map RESULT =null;
		int vuleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vuright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoExpr> vu = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                Map a = new HashMap(); 
                                // a.put("Type", t); 
                                a.put("ExpressionList", vu);
                                RESULT = a; 

                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarSpec_unnecessary_2",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Operand ::= BasicLit 
            {
              GoOperand RESULT =null;
		int blleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int blright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Map bl = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		    
                  RESULT = new GoOperand((String)(bl.get("value")), (String)(bl.get("Type")));  
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Operand",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Operand ::= ArrayType LiteralValue 
            {
              GoOperand RESULT =null;
		int atleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int atright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoArrayType at = (GoArrayType)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int lvleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lvright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoLiteralValue lv = (GoLiteralValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                  RESULT = new GoOperand(at, lv); 
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Operand",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Operand ::= TypeName 
            {
              GoOperand RESULT =null;
		int tnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoTypeName tn = (GoTypeName)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                  RESULT = new GoOperand(tn); // used both for operands (identifiers) and real typenames like int32 etc
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Operand",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Operand ::= open_brac Expression close_brac 
            {
              GoOperand RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                  RESULT = new GoOperand(ex); 
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Operand",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // BasicLit ::= int_lit 
            {
              Map RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String il = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		          
                        Map a = new HashMap(); 
                        a.put("Type", "int"); 
                        a.put("value", il);
                        RESULT = a;  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BasicLit",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // BasicLit ::= float_lit 
            {
              Map RESULT =null;
		int flleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int flright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String fl = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		          
                        Map a = new HashMap(); 
                        a.put("Type", "float"); 
                        a.put("value", fl);
                        RESULT = a;  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BasicLit",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // BasicLit ::= imaginary_lit 
            {
              Map RESULT =null;
		int mlleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mlright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String ml = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		          
                        Map a = new HashMap(); 
                        a.put("Type", "imaginary"); 
                        a.put("value", ml);
                        RESULT = a;  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BasicLit",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // BasicLit ::= rune_lit 
            {
              Map RESULT =null;
		int rlleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rlright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String rl = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		          
                        Map a = new HashMap(); 
                        a.put("Type", "rune"); 
                        a.put("value", rl);
                        RESULT = a;  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BasicLit",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // BasicLit ::= string_lit 
            {
              Map RESULT =null;
		int slleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int slright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String sl = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		          
                      Map a = new HashMap(); 
                      a.put("Type", "string"); 
                      a.put("value", sl);
                      RESULT = a;  
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BasicLit",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // NT$3 ::= 
            {
              GoLiteralValue RESULT =null;
		int llleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int llright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoElementList ll = (GoElementList)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
 RESULT = new GoLiteralValue(ll); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$3",215, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // LiteralValue ::= open_curly_brac LiteralValue_unnecessary_2 NT$3 close_curly_brac 
            {
              GoLiteralValue RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (GoLiteralValue) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int llleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int llright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoElementList ll = (GoElementList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LiteralValue",62, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // LiteralValue_unnecessary_1 ::= comma 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LiteralValue_unnecessary_1",150, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // LiteralValue_unnecessary_1 ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LiteralValue_unnecessary_1",150, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // NT$4 ::= 
            {
              GoElementList RESULT =null;
		int elleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoElementList el = (GoElementList)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
 RESULT = el; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$4",216, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // LiteralValue_unnecessary_2 ::= ElementList NT$4 LiteralValue_unnecessary_1 
            {
              GoElementList RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (GoElementList) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int elleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int elright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoElementList el = (GoElementList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LiteralValue_unnecessary_2",151, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // LiteralValue_unnecessary_2 ::= 
            {
              GoElementList RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LiteralValue_unnecessary_2",151, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // ElementList ::= Element ElementList_unnecessary_1 
            {
              GoElementList RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoElement e = (GoElement)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int e1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoElement> e1 = (LinkedList<GoElement>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 e1.addFirst(e); RESULT = new GoElementList(e1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ElementList",63, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // ElementList_unnecessary_1 ::= ElementList_unnecessary_1 comma Element 
            {
              LinkedList<GoElement> RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		LinkedList<GoElement> e1 = (LinkedList<GoElement>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoElement e = (GoElement)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 e1.add(e); RESULT = e1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ElementList_unnecessary_1",153, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // ElementList_unnecessary_1 ::= 
            {
              LinkedList<GoElement> RESULT =null;
		 RESULT = new LinkedList<GoElement>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ElementList_unnecessary_1",153, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // Element ::= Value 
            {
              GoElement RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoValue v = (GoValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoElement(v); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Element",64, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // Value ::= Expression 
            {
              GoValue RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoValue(ex); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Value",66, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // Value ::= LiteralValue 
            {
              GoValue RESULT =null;
		int lvleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lvright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoLiteralValue lv = (GoLiteralValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoValue(lv); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Value",66, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // PrimaryExpr ::= Operand 
            {
              GoPrimaryExpr RESULT =null;
		int odleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int odright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoOperand od = (GoOperand)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new GoPrimaryExpr(od); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PrimaryExpr",69, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // PrimaryExpr ::= PrimaryExpr Index 
            {
              GoPrimaryExpr RESULT =null;
		int pxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int pxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoPrimaryExpr px = (GoPrimaryExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int inleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int inright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoIndex in = (GoIndex)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                  // we have to see that px formed here does support indexing, ie it is array type, slice type etc
                  String id = px.get_identifier();
                  SymbolTableEntry s = top.get(id);
                  String dataType = s.parsedDataType;
                  // System.out.println("array of type "+s.parsedDataType);
                  // System.out.println("size of array is "+s.size+" while default size is "+s.get_default_size());

                  if ( s.isArray == false )  
                  {
                    System.out.println("ERROR: "+"invalid operation on "+id +": (type "+s.parsedDataType+" does not support indexing)");
                  }
                  RESULT = new GoPrimaryExpr(px, in); 
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PrimaryExpr",69, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // Index ::= open_square_brac Expression close_square_brac 
            {
              GoIndex RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                    // this expression should be non negative integer at run time 
                    // and integer at compile time

                    String dataType_from_exp = ex.get_type(); 

                    dataType_from_exp = get_type_from_symboltable(dataType_from_exp);
                    
                    SymbolTableEntry sym = top.getQuiet(dataType_from_exp);
                    if ( sym != null )  // dataType_from_exp is identifier
                    {
                      dataType_from_exp = sym.parsedDataType;
                      // System.out.println("dataType_from_exp changed to "+dataType_from_exp);
                    }

                    if ( GoConstants.checkIfIntegralNumeric(dataType_from_exp) == false )
                    {
                      System.out.println("ERROR: "+"non-integer array index ");
                    }

                    RESULT = new GoIndex(ex); 
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Index",72, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // Expression ::= UnaryExpr 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoUnaryExpr ux = (GoUnaryExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                  RESULT = new GoExpr(ux,ux.index);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // Expression ::= Expression or_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "||";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // Expression ::= Expression and_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "&&";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // Expression ::= Expression plus_op Expression 
            {
              GoExpr RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "+";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // Expression ::= Expression minus_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "-";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // Expression ::= Expression pipe_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "|";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // Expression ::= Expression pow_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "^";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // Expression ::= Expression equal_equal_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "==";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // Expression ::= Expression not_equal_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "!=";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // Expression ::= Expression greater_equal_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = ">=";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // Expression ::= Expression greater_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = ">";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // Expression ::= Expression less_equal_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "<=";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // Expression ::= Expression less_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "<";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // Expression ::= Expression star_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "*";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // Expression ::= Expression div_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "/";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // Expression ::= Expression mod_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "%";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // Expression ::= Expression left_shift_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "<<";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // Expression ::= Expression right_shift_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = ">>";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // Expression ::= Expression amp_pow_op Expression 
            {
              GoExpr RESULT =null;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "&^";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // UnaryExpr ::= PrimaryExpr 
            {
              GoUnaryExpr RESULT =null;
		int pxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoPrimaryExpr px = (GoPrimaryExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		  
                    if(px.obj2!=null && px.obj2 instanceof GoIndex)
                    {

                      //case of array reference
                      //Assuming expression has been evaluated
                      /*Tac last= quad_array.get(quad_array.size()-1);
                      Tac new_entry;
                      new_entry.op2 = last.res;
                      // String temp_var_name =  next_temp();

                      new_entry.opr="array";*/
                      // new_entry.res= SymbolTablle lookup for a[temp_var_name]
                      String index_res = quad_array.get(((GoIndex)(px.obj2)).expr.index).res;

                      String table_entry_name = px.get_identifier();
                      // System.out.println("@#@#@<InArray>Looking up the tan :"+table_entry_name);
                      
                      Tac new_entry =new Tac();
                      SymbolTableEntry s;
                      s = top.get(table_entry_name);
                      // new_entry.op1= "Mem<"+s.offset+"+"+s.get_default_size()+"*"+index_res+">";
                      new_entry.op1 = "#"+table_entry_name+"#";
                      new_entry.res = next_temp(s.parsedDataType);
                      new_entry.opr = "=";

                      // new_entry.op2 = "#"+index_res+"#"; /***ARRAY INDEXING**/

                      quad_array.add(new_entry);
                    
                      RESULT = new GoUnaryExpr(px,quad_array.size()-1);

                    }
                    else if(px.obj1 instanceof GoOperand )
                    {
                        GoOperand temp= ((GoOperand)px.obj1);
                        if( temp.obj instanceof  String )  //BAsicLit
                        {

                          Tac new_entry =new Tac();
                          new_entry.op1= (String)temp.obj;
                          new_entry.res = next_temp(temp.type);
                          new_entry.opr="=";/***/
                          quad_array.add(new_entry);

                         /* Tac last;
                          if(quad_array.size()==0)
                          {
                            last =new Tac();
                            last.res="sdff";
                          }
                          else
                            last= quad_array.get(quad_array.size()-1);

                          if( last.res ==null )
                          {
                              if(last.push_empty((String)temp.obj)!=0)
                              {
                                System.out.println("ERROR: both operands filled but why is result empty ? ");
                              }
                              if(last.opr!=null)
                                last.res = next_temp();
                          }
                          else if(last.res!=null)
                          {
                            Tac new_entry =new Tac();
                            new_entry.op2= (String)temp.obj;
                            quad_array.add(new_entry);
                          }*/
                         
                          RESULT = new GoUnaryExpr(px,quad_array.size()-1); 
                        }
                        else if (temp.obj instanceof GoTypeName)
                        {
                          
                          String name = ((GoTypeName)temp.obj).typeName;
                          // System.out.println("@#@#@Looking up the tan :"+name);
                          Tac new_entry =new Tac();
                          SymbolTableEntry s;
                          // s = top.get(name);
                          // new_entry.op1= "Mem<"+s.offset+">";
                          new_entry.op1 = "#"+name+"#";
                          new_entry.res = next_temp(temp.type);
                          new_entry.opr= "=";/***/
                          quad_array.add(new_entry);
                        
                          RESULT = new GoUnaryExpr(px,quad_array.size()-1); 

                        }
                        else
                        {
                          // System.out.println("ERROR: Case not handled in PrimaryExpr:Operand");
                        }
                    }
                    else
                    {
                      // System.out.println("ERROR: Case not handled in PrimaryExpr");
                    }
                    // else if( px.obj2)
                    RESULT = new GoUnaryExpr(px,quad_array.size()-1); 
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("UnaryExpr",77, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // UnaryExpr ::= unary_op UnaryExpr 
            {
              GoUnaryExpr RESULT =null;
		int upleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int upright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String up = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoUnaryExpr ux = (GoUnaryExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    Tac last= quad_array.get(ux.index);
                    if( last.res==null ) //PrimaryExpr
                    {
                        //comes form primaryexpr
                        last.opr = up;
                        last.res = next_temp(ux.get_type());
                        // quad_array.add(last);
                        RESULT = new GoUnaryExpr(ux, up,ux.index); 
                      
                    }
                    else //UnaryExpr
                    {
                      Tac new_entry = new Tac();
                      new_entry.op2 = last.res;
                      new_entry.opr = up;
                      new_entry.res = next_temp(ux.get_type());
                      quad_array.add(new_entry);
                      RESULT = new GoUnaryExpr(ux, up,quad_array.size()-1); 
                    }
                    
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("UnaryExpr",77, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // binary_op ::= or_op 
            {
              String RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String o = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "||"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("binary_op",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // binary_op ::= and_op 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "&&"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("binary_op",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // binary_op ::= rel_op 
            {
              String RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String r = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = r; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("binary_op",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // binary_op ::= add_op 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = a; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("binary_op",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // binary_op ::= mul_op 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = m; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("binary_op",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // rel_op ::= equal_equal_op 
            {
              String RESULT =null;
		int eeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String ee = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "=="; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("rel_op",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // rel_op ::= not_equal_op 
            {
              String RESULT =null;
		int neleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int neright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String ne = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "!="; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("rel_op",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // rel_op ::= less_op 
            {
              String RESULT =null;
		int loleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int loright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String lo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "<"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("rel_op",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // rel_op ::= less_equal_op 
            {
              String RESULT =null;
		int leleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int leright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String le = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "<="; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("rel_op",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // rel_op ::= greater_op 
            {
              String RESULT =null;
		int goleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int goright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String go = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ">"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("rel_op",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // rel_op ::= greater_equal_op 
            {
              String RESULT =null;
		int geleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int geright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String ge = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ">="; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("rel_op",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // add_op ::= plus_op 
            {
              String RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "+"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("add_op",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // add_op ::= minus_op 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "-"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("add_op",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // add_op ::= pipe_op 
            {
              String RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "|"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("add_op",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // add_op ::= pow_op 
            {
              String RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "^"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("add_op",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // mul_op ::= star_op 
            {
              String RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "*"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mul_op",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // mul_op ::= div_op 
            {
              String RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String d = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "/"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mul_op",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // mul_op ::= mod_op 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "%"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mul_op",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // mul_op ::= left_shift_op 
            {
              String RESULT =null;
		int lsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String ls = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "<<"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mul_op",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // mul_op ::= right_shift_op 
            {
              String RESULT =null;
		int rsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String rs = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ">>"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mul_op",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // mul_op ::= amp_op 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "&"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mul_op",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // mul_op ::= amp_pow_op 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "&^"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mul_op",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // unary_op ::= plus_op 
            {
              String RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "+"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unary_op",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // unary_op ::= minus_op 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "-"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unary_op",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // unary_op ::= not_op 
            {
              String RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "!"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unary_op",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // unary_op ::= pow_op 
            {
              String RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "^"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unary_op",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // unary_op ::= star_op 
            {
              String RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "*"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unary_op",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // unary_op ::= amp_op 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "&"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unary_op",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Statement ::= Declaration 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // Statement ::= SimpleStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // Statement ::= Func_call 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // Statement ::= ReturnStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // Statement ::= BreakStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // Statement ::= ContinueStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // Statement ::= GotoStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // Statement ::= LabeledStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // Statement ::= Block 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // Statement ::= IfStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // Statement ::= SwitchStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // Statement ::= LabeledForStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // Statement ::= ForStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // SimpleStmt ::= Expression SimpleStmt_unnecessary_1 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		GoExpr e = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int s1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Map s1 = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                  if(s1.get("List1")!=null)
                  {
                      LinkedList<GoExpr> e1= (LinkedList<GoExpr>)(s1.get("List1"));
                      LinkedList<GoExpr> e2= (LinkedList<GoExpr>)(s1.get("List2"));
                      e1.addFirst(e);
                      if(e1.size()!=e2.size())
                      {
                        System.out.println("ERROR: assignment count mismatch: "+e1.size()+" = "+e2.size());
                        // return;
                        // exit(0);
                      }
                      else
                      {
                        for(int i=0;i<e1.size();++i)
                        {
                        /*  Tac left =new Tac();
                          // Tac new_entry = new Tac();
                          // Tac right =new Tac();
                          String val_to_store = quad_array.get(e2.get(i).index).res;

                          String left_id = e1.get(i).get_identifier();
                            System.out.println("*************+++*"+left_id);

                          if(left_id.contains("["))
                          {
                            //Array Here
                            String temp = (left_id.split("\\["))[1];
                            left_id = (left_id.split("\\["))[0];
                            int inside_expr_index = Integer.parseInt((temp.split("\\]"))[0]);
                            SymbolTableEntry s = top.get(left_id);
                            
                           
                            left.res = "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(inside_expr_index).res +">";
                            left.op1= val_to_store;
                            left.opr="=";
                            // new_entry.res = 
                          }
                          else
                          { 
                            System.out.println("**************"+left_id);
                            SymbolTableEntry s = top.get(left_id);
                            left.res = "Mem<"+ s.offset+">";
                            left.op1= val_to_store;
                            left.opr="=";
                             
                            //normal variable here

                          }
                          quad_array.add(left);*/
                          // SymbolTableEntry s = top.get();
                          // quad_array.add(left);
                          // Tac new_entry = new Tac();
                          // new_entry.opr="=";
                          // System.out.println("***************");
                          Tac new_entry2 = new Tac();
                          if(e1.get(i).unaryExpr.obj instanceof GoPrimaryExpr )
                          {
                            //for a[i]
                            if(((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj2!=null)
                            {
                              if(((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj2 instanceof GoIndex)
                              {
                              
                                int index= ((GoIndex)((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj2).expr.index;

                                String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj1).obj1).obj).typeName;
                                SymbolTableEntry s = top.get(id);

                                String dataType_from_e1 = s.parsedDataType;
                                String dataType_from_e2 = e2.get(i).get_type(); 

                                String id_e2 = e2.get(i).get_identifier(); 

                                SymbolTableEntry sym = top.getQuiet(dataType_from_e2);
                                if ( sym != null )  // dataType_from_e2 is identifier
                                {
                                  dataType_from_e2 = sym.parsedDataType;
                                  // System.out.println("dataType_from_e2 changed to "+dataType_from_e2);
                                }
                              
                                dataType_from_e2 = get_type_from_symboltable(dataType_from_e2);


                                if ( dataType_from_e1.equals(dataType_from_e2) == false )
                                {
                                    if ( id_e2 != null )
                                      System.out.println("ERROR: cannot use "+id_e2+"(type "+dataType_from_e2+") as type "+dataType_from_e1+" in assignment 6");
                                    else
                                      System.out.println("ERROR: cannot use "+"(type "+dataType_from_e2+") as type "+dataType_from_e1+" in assignment 7");
                                }
                                else
                                {
                                  // System.out.println("CORRECT: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment");
                                }

                                // new_entry2.res = "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                new_entry2.op1 =quad_array.get(e2.get(i).index).res;
                                new_entry2.opr= "=" ;

                                
                                // new_entry2.op2 = "#"+quad_array.get(index).res+"#"; /***ARRAY INDEXING**/

                                // quad_array.add(new_entry);
                                quad_array.add(new_entry2);
                              }
                              else
                              {
                                System.out.println("ERROR : Illegal increment Operation ");

                              }

                            } 
                            else 
                            {
                              if( ((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj1 instanceof GoOperand )
                              {
                                if(((GoOperand)((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                                {
                                  String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj1).obj).typeName;
                                  SymbolTableEntry s = top.get(id);
                                  // new_entry.op1 = "Mem<"+ s.offset +">";
                                  // new_entry.res = next_temp();
                                  
                                  String dataType_from_e1 = s.parsedDataType;
                                  String dataType_from_e2 = e2.get(i).get_type(); 



                                  String id_e2 = e2.get(i).get_identifier();
                                  SymbolTableEntry sym = top.getQuiet(dataType_from_e2);
                                  if ( sym != null )  // dataType_from_e2 is identifier
                                  {
                                    dataType_from_e2 = sym.parsedDataType;
                                    // System.out.println("dataType_from_e2 changed to "+dataType_from_e2);
                                  } 

                                  dataType_from_e2 = get_type_from_symboltable(dataType_from_e2);

                                  // System.out.println("456456455776 "+dataType_from_e2);
                                  if ( dataType_from_e1.equals(dataType_from_e2) == false )
                                  {
                                      if ( id_e2 != null )
                                        System.out.println("ERROR: cannot use "+id_e2+"(type "+dataType_from_e2+") as type "+dataType_from_e1+" in assignment 8");
                                      else
                                        System.out.println("ERROR: cannot use "+"(type "+dataType_from_e2+") as type "+dataType_from_e1+" in assignment 9");
                                  }
                                  else
                                  {
                                    // System.out.println("CORRECT: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment");
                                  }


                                  // System.out.println("$$$$$$$ offset:" + s.offset+" id : "+id );
                                  // new_entry2.res = "Mem<"+ s.offset +">";
                                  new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset +">";
                                  new_entry2.op1 = quad_array.get((e2.get(i)).index).res;
                                  new_entry2.opr= "=" ;
                                  // quad_array.add(new_entry);
                                  quad_array.add(new_entry2);
                                }
                                else
                                {
                                    System.out.println("ERROR : rvalue can't be assigned to");
                                }
                              }
                              else
                                System.out.println("ERROR : ILLEGAL  OPERATION ");
                            }
                          }
                          else
                          {
                              System.out.println("ERROR : ILLEGAL  OPERATION 1");

                          }
                        }
                      }
                      //TODO  3 address code
                      /*for (int i =0; i<e1.size(); ++i ) 
                      {
                          // e1.get(i).gen();
                          System.out.println(s1.get("assign_op"));
                          // e2.get(i).gen();
                      }*/
                  }
                  else if(s1.get("inc_dec_op")!=null)
                  {
                      // e.gen();
                      // System.out.println(s1.get("inc_dec_op"));
                      Tac new_entry = new Tac();
                      Tac new_entry2 = new Tac();
                      String inc_or_dec = "";
                      if(s1.get("inc_dec_op")=="++")
                      {
                        new_entry.opr = "+";
                        inc_or_dec = "++";
                      }    
                      else
                      {
                        new_entry.opr = "-";
                        inc_or_dec = "--";
                      }
                        
                      new_entry.op2="1";
                      if(e.unaryExpr.obj instanceof GoPrimaryExpr )
                      {
                        //for a[i]
                        if(((GoPrimaryExpr)(e.unaryExpr.obj)).obj2!=null)
                        {
                          if(((GoPrimaryExpr)(e.unaryExpr.obj)).obj2 instanceof GoIndex)
                          {
                          
                            int index= ((GoIndex)((GoPrimaryExpr)(e.unaryExpr.obj)).obj2).expr.index;

                            String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(e.unaryExpr.obj)).obj1).obj1).obj).typeName;
                            SymbolTableEntry s = top.get(id);

                            // now this id should be of numeric type

                            if ( GoConstants.checkIfNumeric(s.parsedDataType) == false )
                            {
                              System.out.println("ERROR: invalid operation: "+inc_or_dec+" (non-numeric type "+s.parsedDataType+" )");
                            }
                            else
                            {
                              //System.out.println("CORRECT: invalid operation: "+inc_or_dec+" (non-numeric type "+s.parsedDataType+" )");
                            }


                            // new_entry.op1 = "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                            new_entry.op1 = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                            new_entry.res = next_temp(s.parsedDataType);
                            new_entry.opr= "=";/***/

                            // new_entry2.res = "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                            new_entry2.res = "#"+id+"#";// "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                            new_entry2.op1 = new_entry.res;
                            new_entry2.opr= "=" ;
                            quad_array.add(new_entry);
                            quad_array.add(new_entry2);
                          }
                          else
                          {
                            System.out.println("ERROR : Illegal increment Operation ");

                          }

                        } 
                        else 
                        {
                          if( ((GoPrimaryExpr)(e.unaryExpr.obj)).obj1 instanceof GoOperand )
                          {
                            //handled for i++
                            if(((GoOperand)((GoPrimaryExpr)(e.unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                            {
                              String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(e.unaryExpr.obj)).obj1).obj).typeName;
                              SymbolTableEntry s = top.get(id);

                              if ( GoConstants.checkIfNumeric(s.parsedDataType) == false )
                              {
                                System.out.println("ERROR: invalid operation: "+inc_or_dec+" (non-numeric type "+s.parsedDataType+" )");
                              }
                              else
                              {
                                //System.out.println("CORRECT: invalid operation: "+inc_or_dec+" (non-numeric type "+s.parsedDataType+" )");
                              }

                              // new_entry.op1 = "Mem<"+ s.offset +">";
                              new_entry.op1 = "#"+id+"#";//"Mem<"+ s.offset +">";
                              new_entry.res = next_temp(s.parsedDataType);
                              new_entry.opr= "=";/***/
                              // new_entry2.res = "Mem<"+ s.offset +">";
                              new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset +">";
                              new_entry2.op1 = new_entry.res;
                              new_entry2.opr= "=" ;
                              quad_array.add(new_entry);
                              quad_array.add(new_entry2);
                            }
                            else
                            {
                                // System.out.println("ERROR : ILLEGAL INCREEMENT OPERATION 2 ");
                            }
                          }
                          // else
                            // System.out.println("ERROR : ILLEGAL INCREEMENT OPERATION ");
                        }
                      }
                      // new_entry.res = "Mem<"+  +">" ;

                      // quad_array.get(e.index.res;
                  }
                   else if(s1.get("func_ass")!=null)
                  {
                      String[] allowed_expected_types = new String[]{"bool","byte","complex64","complex128","float32","float64","int","int8","int16","int32","int64","rune","string","uint","uint8","uint16","uint32","uint64","uintpt"};
                      // System.out.println("GOOD NEWs:  FUnction call assginment working");
                      LinkedList<GoExpr> expr = (LinkedList<GoExpr>)s1.get("func_ass");
                      expr.addFirst(e);
                      String func_name = "_"+((GoFunc_call)(s1.get("func_name"))).typeName.typeName;
                      SymbolTableEntry func_entry = top.get(func_name);
                      if(func_entry !=null )
                      {
                        GoSignature func_sig = (GoSignature)(func_entry.dataType);
                        if(func_sig.obj instanceof LinkedList)//multiple return types
                        {
                          int k=0;
                          LinkedList<GoParameterDecl> return_parameters = (LinkedList<GoParameterDecl>)(func_sig.obj);
                          if(return_parameters.size()==0)
                            System.out.println("ERROR: Can't extract from void function");
                          else
                          {
                            for(int i=0;i<return_parameters.size();++i)
                            {
                              GoParameterDecl params= return_parameters.get(i);
                              if(params.identifierList!=null)
                              {
                                for(int j=0;j<params.identifierList.size();++j)
                                {
                                  if(k==expr.size())
                                  {
                                    System.out.println("ERROR: Too many variables expected from functions");
                                    break;
                                  }
                                  SymbolTableEntry s100 =new SymbolTableEntry(params.type.obj,false,0);

                                  String expr_type = expr.get(k).get_type();
                                  if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                                    expr_type = top.get(expr_type).parsedDataType;
                                  if(!expr_type.equals(s100.parsedDataType))
                                  {
                                   System.out.println("expected : "+expr_type +" Found : "+s100.parsedDataType);
                                   System.out.println("ERROR: Type Mismatch in return_type");
                                  }
                                  
                                  //3AC for pulling out from stack
                                  Tac new_entry2 =new Tac();
                                  if(expr.get(k).unaryExpr.obj instanceof GoPrimaryExpr )
                                  {
                                    //for a[i]
                                    if(((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2!=null)
                                    {
                                      if(((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2 instanceof GoIndex)
                                      {
                                      
                                        int index= ((GoIndex)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2).expr.index;

                                        String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj1).obj).typeName;
                                        SymbolTableEntry s = top.get(id);
                                     
                                     /*   new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                        new_entry2.op1 ="<get_from_stack>";
                                        new_entry2.opr= "=" ;
                                     */   // quad_array.add(new_entry);
                                        new_entry2.op1 = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                        new_entry2.res ="<get_from_stack>";
                                        // new_entry2.opr= "=" ;
                                        
                                        quad_array.add(new_entry2);
                                      }
                                      else
                                      {
                                        // System.out.println("ERROR : UNHANDLED ILLEGAL INCREEMENT OPERATION  ");

                                      }

                                    } 
                                    else 
                                    {
                                      if( ((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1 instanceof GoOperand )
                                      {
                                        if(((GoOperand)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                                        {
                                          String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj).typeName;
                                          SymbolTableEntry s = top.get(id);
                                          // new_entry.op1 = "Mem<"+ s.offset +">";
                                          // new_entry.res = next_temp();
                                          
                                          // System.out.println("$$$$$$$ offset:" + s.offset+" id : "+id );
                                          new_entry2.op1 = "#"+id+"#";//"Mem<"+ s.offset +">";
                                          new_entry2.res ="<get_from_stack>";
                                          // new_entry2.op1 = quad_array.get((e2.get(i)).index).res;
                                          // new_entry2.opr= "=" ;
                                          // quad_array.add(new_entry);
                                          quad_array.add(new_entry2);
                                        }
                                        else
                                        {
                                            // System.out.println("ERROR : ILLEGAL  OPERATION 2 ");
                                        }
                                      }
                                      // else
                                        // System.out.println("ERROR : ILLEGAL  OPERATION ");
                                    }
                                  }
                                  else
                                  {
                                    // System.out.println("ERROR : ILLEGAL  OPERATION 1");
                                  } 
                                  k++;
                                }

                              }
                              else
                              {
                                if(k==expr.size())
                                {
                                  System.out.println("ERROR: Too many variables expected from functions");
                                  break;
                                }
                                SymbolTableEntry s100 =new SymbolTableEntry(params.type.obj,false,0);
                                String expr_type = expr.get(k).get_type();
                                if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                                  expr_type = top.get(expr_type).parsedDataType;
                                if(!expr_type.equals(s100.parsedDataType))
                                {
                                 System.out.println("expected :"+ expr_type +" Found : "+s100.parsedDataType);
                                 System.out.println("ERROR: Type Mismatch in return_type");
                                }
                               
                                Tac new_entry2 =new Tac();
                                if(expr.get(k).unaryExpr.obj instanceof GoPrimaryExpr )
                                {
                                  //for a[i]
                                  if(((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2!=null)
                                  {
                                    if(((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2 instanceof GoIndex)
                                    {
                                    
                                      int index= ((GoIndex)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2).expr.index;

                                      String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj1).obj).typeName;
                                      SymbolTableEntry s = top.get(id);
                                   
                                      new_entry2.op1 = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                      new_entry2.res ="<get_from_stack>";
                                      // new_entry2.opr= "=" ;
                                      // quad_array.add(new_entry);
                                      quad_array.add(new_entry2);
                                    }
                                    else
                                    {
                                      // System.out.println("ERROR : UNHANDLED ILLEGAL INCREEMENT OPERATION  ");

                                    }

                                  } 
                                  else 
                                  {
                                    if( ((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1 instanceof GoOperand )
                                    {
                                      if(((GoOperand)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                                      {
                                        String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj).typeName;
                                        SymbolTableEntry s = top.get(id);
                                        // new_entry.op1 = "Mem<"+ s.offset +">";
                                        // new_entry.res = next_temp();
                                        
                                        // System.out.println("$$$$$$$ offset:" + s.offset+" id : "+id );
                                        new_entry2.op1 = "#"+id+"#";//"Mem<"+ s.offset +">";
                                        new_entry2.res ="<get_from_stack>";
                                        // new_entry2.op1 = quad_array.get((e2.get(i)).index).res;
                                        // new_entry2.opr= "=" ;
                                        // quad_array.add(new_entry);
                                        quad_array.add(new_entry2);
                                      }
                                      else
                                      {
                                          // System.out.println("ERROR : ILLEGAL  OPERATION 2 ");
                                      }
                                    }
                                    // else
                                      // System.out.println("ERROR : ILLEGAL  OPERATION ");
                                  }
                                }
                                else
                                {
                                  // System.out.println("ERROR : ILLEGAL  OPERATION 1");
                                }
                                k++;

                              }
                            }
                          }
                        }
                        else if(func_sig.obj !=null && func_sig.obj instanceof GoType)//single return type
                        {
                           GoType params= (GoType)func_sig.obj;
                           SymbolTableEntry s100 =new SymbolTableEntry(params.obj,false,0);

                            if(expr.size()>1)
                            {
                              System.out.println("ERROR: Too much expected from function");
                            }
                            else
                            {
                              
                              String expr_type = expr.get(0).get_type();
                              if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                                expr_type = top.get(expr_type).parsedDataType;
                              if(!expr_type.equals(s100.parsedDataType))
                              {
                               System.out.println("expected :"+ expr_type +" Found : "+s100.parsedDataType);
                               System.out.println("ERROR: Type Mismatch in Func_ass");
                              }
                              else
                              {

                                Tac new_entry2 =new Tac();
                                if(expr.get(0).unaryExpr.obj instanceof GoPrimaryExpr )
                                {
                                  //for a[i]
                                  if(((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj2!=null)
                                  {
                                    if(((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj2 instanceof GoIndex)
                                    {
                                    
                                      int index= ((GoIndex)((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj2).expr.index;

                                      String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj1).obj1).obj).typeName;
                                      SymbolTableEntry s = top.get(id);
                                   
                                      new_entry2.op1 = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                      new_entry2.res ="<get_from_stack>";
                                      // new_entry2.opr= "=" ;
                                      // quad_array.add(new_entry);
                                      quad_array.add(new_entry2);
                                    }
                                    else
                                    {
                                      // System.out.println("ERROR : UNHANDLED ILLEGAL INCREEMENT OPERATION  ");

                                    }

                                  } 
                                  else 
                                  {
                                    if( ((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj1 instanceof GoOperand )
                                    {
                                      if(((GoOperand)((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                                      {
                                        String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj1).obj).typeName;
                                        SymbolTableEntry s = top.get(id);
                                        // new_entry.op1 = "Mem<"+ s.offset +">";
                                        // new_entry.res = next_temp();
                                        
                                        // System.out.println("$$$$$$$ offset:" + s.offset+" id : "+id );
                                        new_entry2.op1 = "#"+id+"#";//"Mem<"+ s.offset +">";
                                        new_entry2.res ="<get_from_stack>";
                                        // new_entry2.op1 = quad_array.get((e2.get(i)).index).res;
                                        // new_entry2.opr= "=" ;
                                        // quad_array.add(new_entry);
                                        quad_array.add(new_entry2);
                                      }
                                      else
                                      {
                                          // System.out.println("ERROR : ILLEGAL  OPERATION 2 ");
                                      }
                                    }
                                    // else
                                      // System.out.println("ERROR : ILLEGAL  OPERATION ");
                                  }
                                }
                                else
                                {
                                  // System.out.println("ERROR : ILLEGAL  OPERATION 1");
                                }

                              }
                            }
                            
                        }
                        else
                        {
                          //TODO
                          System.out.println("ERROR: Can't assign to Void Function");
                        }

                      }
                      else
                      {
                        System.out.println("ERROR: Function "+func_name +" not defined");
                      }
                  }
                  else
                  {
                      // System.out.println("ERROR:  SimpleStmt");
                  } 
                  
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SimpleStmt",80, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // SimpleStmt ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SimpleStmt",80, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // SimpleStmt_unnecessary_1 ::= ExpressionList_unnecessary_1 assign_op ExpressionList 
            {
              Map RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		LinkedList<GoExpr> e1 = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int auleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int auright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String au = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoExpr> e2 = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                  Map a1 = new HashMap(); 
                                  a1.put("List1", e1); 
                                  a1.put("List2", e2);
                                  a1.put("assign_op",au);
                                  RESULT = a1;
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SimpleStmt_unnecessary_1",205, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // SimpleStmt_unnecessary_1 ::= IncDecStmt_unnecessary_1 
            {
              Map RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String e1 = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                  Map a1 = new HashMap(); 
                                  a1.put("inc_dec_op", e1); 
                                  RESULT = a1;
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SimpleStmt_unnecessary_1",205, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // SimpleStmt_unnecessary_1 ::= ExpressionList_unnecessary_1 assign_op Func_call 
            {
              Map RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		LinkedList<GoExpr> e1 = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int auleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int auright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String au = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int fnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoFunc_call fn = (GoFunc_call)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                  Map a1 = new HashMap(); 
                                  a1.put("func_ass", e1); 
                                  a1.put("func_name",fn);
                                  RESULT = a1;
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SimpleStmt_unnecessary_1",205, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // SimpleStmt_unnecessary_1 ::= 
            {
              Map RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SimpleStmt_unnecessary_1",205, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // IncDecStmt_unnecessary_1 ::= inc_op 
            {
              String RESULT =null;
		 RESULT = "++";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IncDecStmt_unnecessary_1",163, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // IncDecStmt_unnecessary_1 ::= dec_op 
            {
              String RESULT =null;
		 RESULT = "--";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IncDecStmt_unnecessary_1",163, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // assign_op ::= assign_op_unnecessary_1 equal 
            {
              String RESULT =null;
		int auleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int auright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String au = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = au+"=";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assign_op",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // assign_op_unnecessary_1 ::= add_op 
            {
              String RESULT =null;
		int apleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int apright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String ap = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ap;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assign_op_unnecessary_1",164, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // assign_op_unnecessary_1 ::= mul_op 
            {
              String RESULT =null;
		int mlleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mlright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String ml = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ml;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assign_op_unnecessary_1",164, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // assign_op_unnecessary_1 ::= 
            {
              String RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assign_op_unnecessary_1",164, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // NT$5 ::= 
            {
              Map RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr e = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

                if(top!=null) 
                {
                  top = new Env(top,next_env_name(0)); 
                  // System.out.println("NEW TABLE IN If"); 
                }

                String l = next_label();  // used for else if
                String afterIf = next_label();  // after if block ends
                String index_res = quad_array.get( e.index ).res;
                Tac new_entry = new Tac();
                new_entry.op1 = "iffalse " + index_res;
                new_entry.opr = "goto";
                // new_entry.op2 = l;
                new_entry.res = l;
                quad_array.add(new_entry);

                Tac new_entry2 = new Tac();
                new_entry2.res=next_label()+":";
                new_entry2.opr=top.get_name();
                quad_array.add(new_entry2);

                Map a1 = new HashMap(); 
                a1.put("Expr", e); 
                a1.put("Label", l);   // l is for else or else if
                a1.put("AfterIf", afterIf);
                RESULT = a1;

                // RESULT = e;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$5",217, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // Cheez ::= ifd Expression NT$5 open_curly_brac StatementList close_curly_brac 
            {
              Map RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Map) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		GoExpr e = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		 
                // print_sym_table();
                if(top.get_prev()!=null)
                  top = top.get_prev(); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Cheez",92, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // NT$6 ::= 
            {
              Map RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr e = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

                if(top!=null) 
                {
                  top = new Env(top,next_env_name(0)); 
                  // System.out.println("NEW TABLE IN If"); 
                }

                String l = next_label();  // used for else if
                String afterIf = next_label();  // after if block ends
                String index_res = quad_array.get( e.index ).res;
                Tac new_entry = new Tac();
                new_entry.op1 = "iffalse " + index_res;
                new_entry.opr = "goto";
                // new_entry.op2 = l;
                new_entry.res = l;
                quad_array.add(new_entry);

                Tac new_entry2 = new Tac();
                new_entry2.res=next_label()+":";
                new_entry2.opr=top.get_name();
                quad_array.add(new_entry2);
                Map a1 = new HashMap(); 

                a1.put("Expr", e); 
                a1.put("Label", l);   // l is for else or else if
                a1.put("AfterIf", afterIf);
                RESULT = a1;

                // RESULT = e;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$6",218, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // Cheez2 ::= ifd SimpleStmt semicolon Expression NT$6 open_curly_brac StatementList close_curly_brac 
            {
              Map RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Map) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		GoExpr e = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		 
                // print_sym_table();
                if(top.get_prev()!=null)
                  top = top.get_prev(); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Cheez2",93, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // NT$7 ::= 
            {
              GoIfStmt RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 

              Tac new_entry2 = new Tac();
              new_entry2.res = (String)c.get("AfterIf");
              new_entry2.opr = "goto";
              quad_array.add(new_entry2);


              Tac new_entry = new Tac();
              new_entry.res = c.get("Label")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$7",219, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // IfStmt ::= Cheez2 elsed NT$7 IfStmt 
            {
              GoIfStmt RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (GoIfStmt) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int isleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int isright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoIfStmt is = (GoIfStmt)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
              Tac new_entry = new Tac();
              new_entry.res = c.get("AfterIf")+":";
              new_entry.opr = top.get_name();
              
              quad_array.add(new_entry);  
              GoExpr e = (GoExpr)c.get("Expr"); 
              RESULT = new GoIfStmt(e,is,true);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IfStmt",91, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // NT$8 ::= 
            {
              GoIfStmt RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 
              Tac new_entry2 = new Tac();
              new_entry2.res = (String)c.get("AfterIf");
              new_entry2.opr = "goto";
              quad_array.add(new_entry2);

               
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$8",220, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // NT$9 ::= 
            {
              GoIfStmt RESULT =(GoIfStmt) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
 if(top!=null) 
                {
                  top = new Env(top,next_env_name(0));

                  Tac new_entry = new Tac();
                  new_entry.res = c.get("Label")+":";
                  new_entry.opr = top.get_name();

                  quad_array.add(new_entry);
                } 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$9",221, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // IfStmt ::= Cheez2 elsed NT$8 open_curly_brac NT$9 StatementList close_curly_brac 
            {
              GoIfStmt RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (GoIfStmt) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		 
              // print_sym_table();
              if(top.get_prev()!=null)
                top = top.get_prev(); 
             
              Tac new_entry = new Tac();
              new_entry.res = c.get("AfterIf")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry);
              GoExpr e = (GoExpr)c.get("Expr"); 
              RESULT = new GoIfStmt(e,true);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IfStmt",91, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // IfStmt ::= Cheez2 
            {
              GoIfStmt RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		  // no need to create redundant label AfterIf
              Tac new_entry = new Tac();
              new_entry.res = c.get("Label")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry); 
              GoExpr e = (GoExpr)c.get("Expr"); RESULT = new GoIfStmt(e); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IfStmt",91, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // NT$10 ::= 
            {
              GoIfStmt RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 

              Tac new_entry2 = new Tac();
              new_entry2.res = (String)c.get("AfterIf");
              new_entry2.opr = "goto";
              quad_array.add(new_entry2);


              Tac new_entry = new Tac();
              new_entry.res = c.get("Label")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$10",222, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // IfStmt ::= Cheez elsed NT$10 IfStmt 
            {
              GoIfStmt RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (GoIfStmt) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int isleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int isright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoIfStmt is = (GoIfStmt)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
              Tac new_entry = new Tac();
              new_entry.res = c.get("AfterIf")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry);  
              GoExpr e = (GoExpr)c.get("Expr"); 
              RESULT = new GoIfStmt(e,is,true);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IfStmt",91, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // NT$11 ::= 
            {
              GoIfStmt RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 
              Tac new_entry2 = new Tac();
              new_entry2.res = (String)c.get("AfterIf");
              new_entry2.opr = "goto";
              quad_array.add(new_entry2);

            
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$11",223, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // NT$12 ::= 
            {
              GoIfStmt RESULT =(GoIfStmt) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
 if(top!=null) 
                {
                  top = new Env(top,next_env_name(0));

                  Tac new_entry = new Tac();
                  new_entry.res = c.get("Label")+":";
                  new_entry.opr = top.get_name();

                  quad_array.add(new_entry);
                } 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$12",224, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // IfStmt ::= Cheez elsed NT$11 open_curly_brac NT$12 StatementList close_curly_brac 
            {
              GoIfStmt RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (GoIfStmt) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		 
              // print_sym_table();
              if(top.get_prev()!=null)
                top = top.get_prev(); 
              
              Tac new_entry = new Tac();
              new_entry.res = c.get("AfterIf")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry);

              GoExpr e = (GoExpr)c.get("Expr"); 
              RESULT = new GoIfStmt(e,true);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IfStmt",91, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // IfStmt ::= Cheez 
            {
              GoIfStmt RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Map c = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		  // no need to create redundant label AfterIf
              Tac new_entry = new Tac();
              new_entry.res = c.get("Label")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry); 
              GoExpr e = (GoExpr)c.get("Expr"); RESULT = new GoIfStmt(e); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IfStmt",91, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // SwitchStmt ::= ExprSwitchStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SwitchStmt",87, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // ExprSwitchStmt ::= switchd SimpleStmt semicolon Expression open_curly_brac ExprSwitchStmt_unnecessary_3 close_curly_brac 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprSwitchStmt",101, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // ExprSwitchStmt ::= switchd Expression open_curly_brac ExprSwitchStmt_unnecessary_3 close_curly_brac 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprSwitchStmt",101, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // ExprSwitchStmt ::= switchd open_curly_brac ExprSwitchStmt_unnecessary_3 close_curly_brac 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprSwitchStmt",101, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // ExprSwitchStmt ::= switchd SimpleStmt semicolon open_curly_brac ExprSwitchStmt_unnecessary_3 close_curly_brac 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprSwitchStmt",101, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // ExprSwitchStmt_unnecessary_3 ::= ExprSwitchStmt_unnecessary_3 ExprCaseClause 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprSwitchStmt_unnecessary_3",170, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // ExprSwitchStmt_unnecessary_3 ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprSwitchStmt_unnecessary_3",170, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // ExprCaseClause ::= cased ExpressionList colon StatementList 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprCaseClause",103, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // ExprCaseClause ::= defaultd colon StatementList 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprCaseClause",103, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // NT$13 ::= 
            {
              GoForStmt RESULT =null;
 
                top = new Env(top,next_env_name(0)); 
                // System.out.println("NEW TABLE IN For");

                String fraudForForClauseSimpleStmt = next_label();
                
                Tac new_entry2 = new Tac();
                new_entry2.res = fraudForForClauseSimpleStmt+":";
                new_entry2.opr = top.get_name();

                quad_array.add(new_entry2);


                String condCheck = next_label();
                
                Tac new_entry = new Tac();
                new_entry.res = condCheck+":";
                new_entry.opr = top.get_name();

                quad_array.add(new_entry);
                SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1,condCheck);
                top.put("for<>", s);
                // f = condCheck;
                 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$13",225, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // NT$14 ::= 
            {
              GoForStmt RESULT =(GoForStmt) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int fuleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int furight = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Map fu = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
 
              String outOfFor = (String)fu.get("outOfFor");
              String forBlock = (String)fu.get("forBlock"); 
              String update = (String)fu.get("update");
              

              SymbolTableEntry s = top.getQuiet("for<>");

              if ( forBlock != null ) // we are in for instead of while
              {
                Tac new_entry = new Tac();
                new_entry.res = forBlock+":";
                new_entry.opr = top.get_name();
                quad_array.add(new_entry);
                
                
                quad_array.remove( s.size); // removing whileStart since that is done in forClause
                
              }
              LinkedList<String> forLabels = new LinkedList<String>();

              if ( update == null ) // coming from a while loop
                update = s.parsedDataType;

              fu.put("forStart", s.parsedDataType);

              forLabels.add(s.parsedDataType);  // forLabels[0] = forStart ie condCheck
              forLabels.add(outOfFor);          // forLabel[1] =  outOfFor
              forLabels.add(update);            // forLabels[2] = update in case of for
              s.dataType = (LinkedList<String>)forLabels; // to help the labeled for statement
              top.update("for<>", s);

              SymbolTableEntry s2 = top.getFromParent("for<label>");

              if ( s2 != null )
              {
                String label = s2.parsedDataType; // this is the unique label for this for
                top.removeFromParent("for<label>"); // remove this entry from parent so that other fors of parent can use it

                SymbolTableEntry s3 = top.getFromParent(label);
                s3.dataType = (LinkedList<String>)forLabels;
                top.update(label, s3);
              }

            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$14",226, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // ForStmt ::= ford NT$13 ForStmt_unnecessary_1 NT$14 open_curly_brac StatementList close_curly_brac 
            {
              GoForStmt RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (GoForStmt) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int fuleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int furight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Map fu = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		 
                String update = (String)fu.get("update");
                if(update==null)
                  update = top.getQuiet("for<>").parsedDataType;
                
                Tac new_entry = new Tac();
                new_entry.res = update;
                new_entry.opr = "goto";
                quad_array.add(new_entry);
                
                if(top.get_prev()!=null)
                  top = top.get_prev(); 

                String outOfFor = (String)fu.get("outOfFor"); 
                Tac new_entry2 = new Tac();
                new_entry2.res = outOfFor+":";
                new_entry2.opr = top.get_name();
                quad_array.add(new_entry2);

                // print_sym_table();


                String forBlock = (String)fu.get("forBlock"); 
                String forStart = (String)fu.get("forStart");
                RESULT = new GoForStmt(forStart, forBlock, update, outOfFor); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ForStmt",90, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // ForStmt ::= ForStmt_unnecessary_2 open_curly_brac StatementList close_curly_brac 
            {
              GoForStmt RESULT =null;
		int fuleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int furight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Map fu = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		 
                  String forStart = (String)fu.get("forStart");
                  Tac new_entry = new Tac();
                  new_entry.res = forStart;
                  new_entry.opr = "goto";
                  quad_array.add(new_entry);

                  // print_sym_table();
                  if(top.get_prev()!=null)
                    top = top.get_prev();

                  String outOfFor = (String)fu.get("outOfFor"); 
                  Tac new_entry2 = new Tac();
                  new_entry2.res = outOfFor+":";
                  new_entry2.opr = top.get_name();
                  quad_array.add(new_entry2);



                  String forBlock = forStart;
                  String update = forStart;
                  RESULT = new GoForStmt(forStart, forBlock, update, outOfFor);  
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ForStmt",90, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // ForStmt_unnecessary_2 ::= ford 
            {
              Map RESULT =null;
		 
                top = new Env(top,next_env_name(0)); 

                String forStart = next_label();
                Tac new_entry = new Tac();
                new_entry.res = forStart+":";
                new_entry.opr = top.get_name();
                quad_array.add(new_entry);

                // System.out.println("NEW TABLE IN For");
                

                String outOfFor = next_label(); // we are generating out of for before hand so that statements inside the infinite loop can access  it to break out


                SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1, outOfFor);
                top.put("for<>", s);

                SymbolTableEntry s2 = top.getQuiet("for<>");
                LinkedList<String> forLabels = new LinkedList<String>();
                forLabels.add(forStart);  // s.parsedDataType
                forLabels.add(outOfFor);
                forLabels.add(forStart);  // the update statement is same as forStart
                s2.dataType = (LinkedList<String>)forLabels;

                SymbolTableEntry s4 = top.getFromParent("for<label>");
                if ( s4 != null ) // if we do have a label for for
                {
                  String label = s4.parsedDataType; // this is the unique label for this for
                  top.removeFromParent("for<label>"); // remove this entry from parent so that other fors of parent can use it

                  SymbolTableEntry s3 = top.getFromParent(label);
                  s3.dataType = (LinkedList<String>)forLabels;
                  top.update(label, s3);
                }

                Map cm = new HashMap();
                cm.put("forStart", forStart);
                cm.put("outOfFor", outOfFor);
                RESULT = cm; 

            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ForStmt_unnecessary_2",180, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // ForStmt_unnecessary_1 ::= Expression 
            {
              Map RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr e = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                           
                              String outOfFor = next_label();
                              
                              String index_res = quad_array.get( e.index ).res;
                              Tac new_entry2 = new Tac();
                              new_entry2.op1 = "iffalse " + index_res;
                              new_entry2.opr = "goto";
                              // new_entry.op2 = l;
                              new_entry2.res = outOfFor;
                              quad_array.add(new_entry2);

                              // Generate a forStart here also as we require is for LeaderBlock
                              String forStart = next_label();
                                Tac new_entry = new Tac();
                                new_entry.res = forStart+":";
                                new_entry.opr = top.get_name();
                                quad_array.add(new_entry);


                              Map cm = new HashMap();
                              cm.put("outOfFor", outOfFor);
                              // cm.put("update", condCheck);

                              RESULT = cm;
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ForStmt_unnecessary_1",179, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // ForStmt_unnecessary_1 ::= ForClause 
            {
              Map RESULT =null;
		int fcleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fcright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Map fc = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              RESULT = fc;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ForStmt_unnecessary_1",179, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // NT$15 ::= 
            {
              Map RESULT =null;
		int fuleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int furight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String fu = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int cmleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cmright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Map cm = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

                  GoExpr e = (GoExpr)cm.get("Expr");
                  String outOfFor = next_label();
                  if ( e != null )  // condition exists
                  {  
                    String index_res = quad_array.get( e.index ).res;
                    Tac new_entry = new Tac();
                    new_entry.op1 = "iffalse " + index_res;
                    new_entry.opr = "goto";
                    // new_entry.op2 = l;
                    new_entry.res = outOfFor;
                    quad_array.add(new_entry);

                 }

                  String forBlock = next_label();

                  Tac new_entry2 = new Tac();
                  new_entry2.res = forBlock;
                  new_entry2.opr = "goto";
                  quad_array.add(new_entry2);

                  String update = next_label();
                  Tac new_entry3 = new Tac();
                  new_entry3.res = update+":";
                  new_entry3.opr = top.get_name();
                  quad_array.add(new_entry3);

                  cm.put("outOfFor", outOfFor);
                  cm.put("update", update);
                  cm.put("forBlock", forBlock);
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$15",227, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // ForClause ::= ForClause_Unneccesary Condition_unnecessary_1 semicolon NT$15 SimpleStmt 
            {
              Map RESULT =null;
              // propagate RESULT from NT$15
                RESULT = (Map) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int fuleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int furight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		String fu = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int cmleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int cmright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Map cm = (Map)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		
                  String condCheck = fu;
                  Tac new_entry2 = new Tac();
                  new_entry2.res = condCheck;
                  new_entry2.opr = "goto";
                  quad_array.add(new_entry2);

                  RESULT = cm;
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ForClause",110, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // ForClause_Unneccesary ::= SimpleStmt semicolon 
            {
              String RESULT =null;
		
                              String condCheck = next_label();
                              Tac new_entry = new Tac();
                              new_entry.res = condCheck+":";
                              new_entry.opr = top.get_name();

                              quad_array.add(new_entry);
                              RESULT = condCheck;
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ForClause_Unneccesary",210, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // Condition_unnecessary_1 ::= Expression 
            {
              Map RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr e = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Map cm = new HashMap(); cm.put("Expr", e); RESULT = cm; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Condition_unnecessary_1",183, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // Condition_unnecessary_1 ::= 
            {
              Map RESULT =null;
		 Map cm = new HashMap(); RESULT = cm; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Condition_unnecessary_1",183, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // ReturnStmt ::= returnd ExpressionList 
            {
              Object RESULT =null;
		int elleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<GoExpr> el = (LinkedList<GoExpr>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                if(top.parent == null)
                {
                  System.out.println("ERROR : Return statement written in a global scope");
                }
                if( top.get("return[0]") ==null )
                  System.out.println("ERROR : VOID RETURN TYPE ");
                else
                {
                    SymbolTableEntry s = new SymbolTableEntry();
                    top.put("@return@",s);//for checking return statement presence
                    //TODO-DONE 3AC for return statement
                    //Store the variables expecting result and then store the values of the current variable in the parent's symmbol table and then jump to lasr statement
                    String[] allowed_expected_types =  new String[] {"int","imaginary","float","rune","string"};
                    for(int i=0;i<el.size();++i)
                    {
                      if( top.get("return["+i+"]") !=null )
                      {

                        String expected_type=top.get("return["+i+"]").parsedDataType;//this will be fixed and more confident type
                        String return_type = el.get(i).get_type(); //this can be loose as sand
                        if(!Arrays.asList(allowed_expected_types).contains(return_type))//-->This is for variables
                           return_type = top.get(return_type).parsedDataType;
                        
                        if( !expected_type.contains(return_type) )
                        { 
                          System.out.println("ERROR : Return Type Mismatch");
                          System.out.println("expected_type : "+expected_type+" return_type "+return_type);
                          // break;
                        }
                        else
                        {
                          Tac new_entry =new Tac();
                          new_entry.res = "push_ret";
                          new_entry.op1 = quad_array.get(el.get(i).index).res;
                          quad_array.add(new_entry);
                        }
                      }
                      else
                      {
                        System.out.println("ERROR : too many return variables!");
                        break;
                      }
                    }
                    if(top.get("return["+el.size()+"]") !=null)
                        System.out.println("ERROR : too few return variables!");
                }

                // System.out.println(" RETURNED HERE "+el.get(0).get_type());

              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ReturnStmt",82, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // ReturnStmt ::= returnd 
            {
              Object RESULT =null;
		
                  if(top.parent == null)
                  {
                    System.out.println("ERROR : Return statement written in a global scope");
                  }
                  SymbolTableEntry s = new SymbolTableEntry();
                  top.put("@return@",s); //for checking return statement presence
               
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ReturnStmt",82, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // BreakStmt ::= breakd identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    if(top.getQuiet("for<>")==null)
                    {
                        System.out.println("ERROR: break is not in a loop");
                    }
                    else
                    {
                        SymbolTableEntry s = top.get(i);
                        if ( s == null )
                        {
                          System.out.println("ERROR: break label not defined: "+i);
                        }
                        else
                        {
                          // checking if that label is a label type or not
                          if ( s.parsedDataType == "for<label>" )
                          {
                            Tac new_entry = new Tac();
                            // if ( i != quad_array.get(s.size).res )
                            // {
                              // System.out.println("ERROR: CRRRRAP");
                            // }
                            new_entry.res = ((LinkedList<String>)s.dataType).get(1);// ((LinkedList<String>)s.dataType).get(1);  // 1 for outOfFor
                            new_entry.opr = "goto";
                            quad_array.add(new_entry);
                            // System.out.println("Breaking out of a block. Using identifier with a break"+i);

                            // now we need to create a new label for LeaderBlock
                            String label = next_label();
                            Tac new_entry2 = new Tac();
                            new_entry2.res = label+":";
                            new_entry2.opr = top.get_name();
                            quad_array.add(new_entry2);
                          }
                          else
                          {
                            System.out.println("ERROR: invalid break label "+i);
                          }
                          
                        } 
                    }
                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BreakStmt",83, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // BreakStmt ::= breakd 
            {
              Object RESULT =null;
		 
                    if( top.getQuiet("for<>") == null )
                    {
                        System.out.println("ERROR: break is not in a loop");
                    }
                    else
                    {
                        String outOfFor = (String) ((LinkedList<String>)top.getQuiet("for<>").dataType).get(1); // 0 contains forStart
                        Tac new_entry = new Tac();
                        new_entry.res = outOfFor;
                        new_entry.opr = "goto";
                        quad_array.add(new_entry);
                        // System.out.println("Breaking out of For Loop");

                        // now we need to create a new label for LeaderBlock
                            String label = next_label();
                            Tac new_entry2 = new Tac();
                            new_entry2.res = label+":";
                            new_entry2.opr = top.get_name();
                            quad_array.add(new_entry2);
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BreakStmt",83, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // Label ::= identifier colon 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                    // System.out.println("New LabeledStmt is called with identifier :"+i);

                    String label =  i;
                    Tac new_entry = new Tac();
                    new_entry.res = label+":";
                    new_entry.opr = top.get_name();

                    quad_array.add(new_entry);

                    SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1,"<label>");
                    top.put(label, s);
                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Label",99, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // LabeledStmt ::= Label Declaration 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // LabeledStmt ::= Label SimpleStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // LabeledStmt ::= Label Func_call 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // LabeledStmt ::= Label ReturnStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // LabeledStmt ::= Label BreakStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // LabeledStmt ::= Label ContinueStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // LabeledStmt ::= Label GotoStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // LabeledStmt ::= Label LabeledStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // LabeledStmt ::= Label Block 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // LabeledStmt ::= Label IfStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // LabeledStmt ::= Label SwitchStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // LabeledStmt ::= Label LabeledForStmt 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledStmt",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // NT$16 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 
                    // System.out.println("New LabeledForStmt is called with identifier :"+i);

                    String label =  i;
                    Tac new_entry = new Tac();
                    new_entry.res = label+":";
                    new_entry.opr = top.get_name();
                    
                    quad_array.add(new_entry);

                    SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1,"for<label>");
                    top.put(label, s);
                    SymbolTableEntry s2 = new SymbolTableEntry(quad_array.size()-1,label);
                    top.put("for<label>", s2);  // now will search it in forStmt to see if any label attached to it.
                    // Since each for can have atmost 1 label attached to it, we will find only one entry in its parent's symbol table entry.
                    // As soon as we use this entry, we will delete it so that other for's can have their labels in the parent's ST
                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$16",228, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // LabeledForStmt ::= identifier colon NT$16 ForStmt 
            {
              Object RESULT =null;
              // propagate RESULT from NT$16
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LabeledForStmt",79, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // GotoStmt ::= gotod identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                  SymbolTableEntry s = top.getLabel(i);
                  if ( s == null )
                  {
                    System.out.println("ERROR: label "+i+" not defined"); 
                  }
                  else
                  {
                    // System.out.println("New GotoStmt is called with identifier :"+i); 
                    Tac new_entry = new Tac();
                    new_entry.res = i;
                    new_entry.opr = "goto";
                    quad_array.add(new_entry);         

                    // now we need to create a new label for LeaderBlock
                    String label = next_label();
                    Tac new_entry2 = new Tac();
                    new_entry2.res = label+":";
                    new_entry2.opr = top.get_name();
                    quad_array.add(new_entry2);

                  }
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("GotoStmt",85, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // ContinueStmt ::= continued identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                  if( top.getQuiet("for<>") == null )
                  {
                      System.out.println("ERROR: continue is not in a loop");
                  }
                  else
                  {
                      SymbolTableEntry s = top.get(i);
                      if ( s == null )
                      {
                        System.out.println("ERROR: continue label not defined: "+i);
                      }
                      else
                      {
                        // checking if that label is a label type or not
                        if ( s.parsedDataType == "for<label>" )
                        {
                          Tac new_entry = new Tac();
                          // if ( i != quad_array.get(s.size).res )
                          // {
                            // System.out.println("ERROR: CRRRRAP");
                          // }
                          new_entry.res = ((LinkedList<String>)s.dataType).get(2);  // 2 for update
                          new_entry.opr = "goto";
                          quad_array.add(new_entry);
                          // System.out.println("Continuing to top of a block. Using identifier "+i);

                          // now we need to create a new label for LeaderBlock
                            String label = next_label();
                            Tac new_entry2 = new Tac();
                            new_entry2.res = label+":";
                            new_entry2.opr = top.get_name();
                            quad_array.add(new_entry2);


                        }
                        else
                        {
                          System.out.println("ERROR: invalid continue label "+i);
                        }
                        
                      } 
                  }
               
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ContinueStmt",84, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // ContinueStmt ::= continued 
            {
              Object RESULT =null;
		 
                    if( top.getQuiet("for<>") == null )
                    {
                        System.out.println("ERROR: continue is not in a loop");
                    }
                    else
                    {
                        String forStartorUpdate = (String) ((LinkedList<String>)top.getQuiet("for<>").dataType).get(2); // 0 contains forStart
                        Tac new_entry = new Tac();
                        new_entry.res = forStartorUpdate;
                        new_entry.opr = "goto";
                        quad_array.add(new_entry);
                        // System.out.println("Continuing to top of For Loop.");

                        // now we need to create a new label for LeaderBlock
                          String label = next_label();
                          Tac new_entry2 = new Tac();
                          new_entry2.res = label+":";
                          new_entry2.opr = top.get_name();
                          quad_array.add(new_entry2);

                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ContinueStmt",84, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // NT$17 ::= 
            {
              Object RESULT =null;
 top =null; gen_registers(); /*Tac fraud = new Tac("2","+","1","1");
  quad_array.add(fraud);*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$17",229, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // NT$18 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
 
    top = new Env(top,next_env_name(0));
    Env.global_env = top;

    Tac new_entry = new Tac();
    new_entry.res = "GLOBAL:";
    new_entry.opr = top.get_name();
    quad_array.add(new_entry);
    // System.out.println("NEW GLOBAL TABLE");
  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$18",230, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // SourceFile ::= NT$17 PackageClause semicolon SourceFile_unnecessary_1 NT$18 SourceFile_unnecessary_2 
            {
              Object RESULT =null;
              // propagate RESULT from NT$18
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    // System.out.println("Changing Tables");
                   // print_sym_table();
                   // print_qaud_array();
               next_step();

              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SourceFile",118, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // SourceFile_unnecessary_1 ::= SourceFile_unnecessary_1_dash 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SourceFile_unnecessary_1",192, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // SourceFile_unnecessary_1_dash ::= ImportDecl semicolon SourceFile_unnecessary_1_dash 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SourceFile_unnecessary_1_dash",199, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // SourceFile_unnecessary_1_dash ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SourceFile_unnecessary_1_dash",199, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // SourceFile_unnecessary_2 ::= SourceFile_unnecessary_2_dash 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SourceFile_unnecessary_2",193, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // SourceFile_unnecessary_2_dash ::= TopLevelDecl semicolon SourceFile_unnecessary_2_dash 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SourceFile_unnecessary_2_dash",200, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // SourceFile_unnecessary_2_dash ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SourceFile_unnecessary_2_dash",200, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // PackageClause ::= packaged identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                      Tac new_entry = new Tac();
                          new_entry.res = "package";
                          new_entry.op1 = i;
                          quad_array.add(new_entry);
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PackageClause",119, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // ImportDecl ::= importd ImportDecl_unnecessary_2 
            {
              Object RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<String> il = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                Tac new_entry;
                for ( int q = 0; q < il.size(); q++ )
                {
                  new_entry = new Tac();
                  new_entry.res = "import";
                  new_entry.op1 = il.get(q);
                  quad_array.add(new_entry);
                }
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ImportDecl",120, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // ImportDecl_unnecessary_1 ::= ImportDecl_unnecessary_1 ImportSpec semicolon 
            {
              LinkedList<String> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		LinkedList<String> il = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		LinkedList<String> i = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                  for ( int q = 0; q < i.size(); q++ )
                                  {
                                    il.add(i.get(q));
                                  }
                                  RESULT = il;
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ImportDecl_unnecessary_1",194, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // ImportDecl_unnecessary_1 ::= 
            {
              LinkedList<String> RESULT =null;
		
                                LinkedList<String> a = new LinkedList<String>();
                                RESULT = a;
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ImportDecl_unnecessary_1",194, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // ImportDecl_unnecessary_2 ::= ImportSpec 
            {
              LinkedList<String> RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LinkedList<String> i = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = i; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ImportDecl_unnecessary_2",195, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // ImportDecl_unnecessary_2 ::= open_brac ImportDecl_unnecessary_1 close_brac 
            {
              LinkedList<String> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		LinkedList<String> il = (LinkedList<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = il; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ImportDecl_unnecessary_2",195, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // ImportSpec ::= dot string_lit 
            {
              LinkedList<String> RESULT =null;
		int slleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int slright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String sl = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                LinkedList<String> a = new LinkedList<String>(); 
                a.add("."); a.add(sl); 
                RESULT = a; 
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ImportSpec",121, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // ImportSpec ::= identifier string_lit 
            {
              LinkedList<String> RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int slleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int slright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String sl = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                LinkedList<String> a = new LinkedList<String>(); 
                a.add(i); a.add(sl); 
                RESULT = a; 
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ImportSpec",121, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // ImportSpec ::= string_lit 
            {
              LinkedList<String> RESULT =null;
		int slleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int slright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String sl = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                LinkedList<String> a = new LinkedList<String>(); 
                // a.add(""); 
                a.add(sl); 
                RESULT = a; 
              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ImportSpec",121, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          case 241: // inter_op
          {
            String RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "?"; 
            CUP$Parser$result = parser.getSymbolFactory().newSymbol("inter_op",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
          }
        return CUP$Parser$result;
        
          case 242: 
          {
            GoExpr RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		GoExpr ex = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int boleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int boright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String bo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int uxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int uxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		GoExpr ux = (GoExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                  // int expr_index = ;
                  Tac expr = quad_array.get(ex.index);
                  Tac unexpr = quad_array.get(ux.index);
                  Tac new_entry = new Tac();
                  new_entry.res = next_temp(ex.get_type())+"";
                  new_entry.opr = "?";
                  new_entry.op1= unexpr.res;
                  new_entry.op2= expr.res;
                  quad_array.add(new_entry);
                  // print_qaud_array();
                  RESULT = new GoExpr(ex,ux,quad_array.size()-1);

              
            CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expression",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
          }
        return CUP$Parser$result;
          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
